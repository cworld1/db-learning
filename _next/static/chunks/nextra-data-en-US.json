{"/00-at-the-beginning":{"title":"At the Beginning","data":{"数据库原理与应用是一门新兴学科#数据库原理与应用是一门新兴学科":"","数据库系统的发展#数据库系统的发展":"层次/网路偶数据库系统 → 关系数据库系统 → 新一代数据库系统","数据库自身的时代价值#数据库自身的时代价值":"数据库的发展也诞生了一门新的计算机基础学科：一数据建模和 DBMS 核心技术为主，内容丰富领域宽广带动了一个巨大的软件产业：DBMS 及其相关工具产品、应用套件、解决方案","数据库专业的地位#数据库专业的地位":"数据库技术和系统已经成为信息系统的核心计数和重要基础设施。"}},"/01-ds-sys-summary":{"title":"第 1 章 数据库系统概述","data":{"数据与信息#数据与信息":"信息 = 数据 + 语义。数据表示了信息，而信息只有通过数据形式表示出来才能被人们理解和接受。数据处理是将数据转换成信息的过程，包括对数据的收集、管理、加工利用乃至信息输出等一系列活动。","为什么要学习-ds#为什么要学习 DS":"为什么要学习 Database？\nShift from computation to information\nAlways been true for corporate computing\nThe Web made this point for personal computing\nMore so true for scientific computing\nBig Data (Volume 体积, Variety 种类, Velocity 速度, Veracity 真实性)\nDigital libraries, life science projects\nMultimedia databases, social web (Facebook, Twitter, You Tube)\nSemantic annotations(语义注释), sensor data(感知数据), uncertain data","四种数据模型#四种数据模型":"目前，在数据库领域中常用的数据模型主要有层次模型（Hierarchical Model）、网状模型（Network Model）、关系模型（Relational Model）和面向对象模型（Object-oriented Model）四种。","层次模型#层次模型":"每棵树有且仅有一个结点没有双亲，该结点就是根结点。\n根结点以外的其他结点有且仅有一个双亲结点。\n父子结点之间的联系是一对多（1:n）的联系。父结点中的一个记录值可能对应 n 个子结点中的记录值，而子结点中的一个记录值只能对应父结点中一个记录值。因此，任何一个给定的记录值只有按其路径查看时，才能显出它的全部意义，没有一个子女记录值能够脱离双亲记录值而独立存在。","网状模型#网状模型":"层次模型只能有一个根结点，根结点以外的其他结点有且仅有一个双亲结点。而网状模型中取消了层次模型的这两个限制，它允许多个结点没有双亲结点，允许结点可以有多个双亲结点。因此，网状模型是采用有向图结构表示记录型与记录型之间联系的数据模型，它可以更直接地描述现实世界，层次模型实际上是网状模型的一个特例。","关系模型#关系模型":"关系模型是发展较晚的一种模型。关系模型的数据结构是一张规范化的二维表，它由表名、表头和表体三部分构成。表名即二维表的名称，表头决定了二维表的结构（即表中列数及每列的列名、类型等），表体即二维表中的数据。每个二维表又可称为关系。","数据库#数据库":"","什么是数据库#什么是数据库":"A database is a very large, intergrated(集成) and commonly used collection of data.数据库（Database，简称 DB）是长期储存在计算机内、有组织的、可共享的大量数据的集合。","数据库的特点#数据库的特点":"集成性。将某特定应用环境中的各种应用相关的数据及其数据之间的联系全部集中地并按照一定的结构形式进行存储，或者说，把数据库看成为若干个性质不同的数据文件的联合和统一的数据整体。\n共享性。数据库中的数据可为多个不同的用户所共享，即多个不同的用户可使用多种不同的语言，为了不同的应用目的，而同时存取数据库，甚至同时存取数据库中的同一数据。","数据模型#数据模型":"数据模型：A collection of concepts for describing dataSchema: An abstract description of database using the given data modelschema 是元数据的一个抽象集合。模式（Schema）是数据库中全体数据的逻辑结构和特征的描述。\nPhysical schema：物理存储结构\nLogical schema：如 Data Definition Language (DDL) 等数据定义方式\nExternal schema：如 Data Manipulation Language (DML)","数据库系统#数据库系统":"","数据库组成#数据库组成":"数据库系统（DataBase System，DBS）是指在计算机系统中引入数据库后的系统。它主要由数据库（DB）、数据库用户、计算机硬件系统和计算机软件系统等几部分组成。","数据库-1#数据库":"A database is a very large, intergrated(集成) and commonly used collection of data.数据库（Database，简称 DB）是长期储存在计算机内、有组织的、可共享的大量数据的集合。","用户#用户":"用户是指使用数据库的人，他们可对数据库进行存储、维护和检索等操作。用户分为以下三类：\n第一类用户：即最终用户（End User）。最终用户主要是使用数据库的各级管理人员、工程技术人员和科研人员，一般为非计算机专业人员。他们主要利用已编写好的应用程序接口使用数据库。\n第二类用户：即应用程序员（Application Programmer）。应用程序员负责为最终用户设计和编写应用程序，并进行调试和安装，以便最终用户利用应用程序对数据库进行存取操作。\n第三类用户：即数据库管理员（DataBase Administrator，DBA）。数据库管理员是负责设计、建立、管理和维护数据库以及协调用户对数据库要求的个人或工作团队。DBA 应熟悉计算机的软硬件系统，具有较全面的数据处理知识，熟悉最终用户的业务、数据及其流程。\n其中的 DBA 的主要职责：\n参与数据库设计的全过程，决定整个数据库的结构和信息内容。\n决定数据库的存储结构和存取策略，以获得较高的存取效率和存储空间利用率。\n帮助应用程序员使用数据库系统，如培训、解答应用程序员日常使用数据库系统时遇到的问题等。\n定义数据的安全性和完整性约束条件，负责分配各个应用程序对数据库的存取权限，确保数据的安全性和完整性。\n监控数据库的使用和运行，定义和实施适当的数据库备份和恢复策略；当数据库的结构需要改变时，完成对数据结构的修改。\n改进和重构数据库，监视数据库系统运行期间的空间利用率、处理效率等性能指标，不断提高系统的性能；根据用户需求情况的变化，对数据库进行重新构造。","软件系统#软件系统":"软件（Software）系统主要包括操作系统（Operating System，OS）、数据库管理系统（DBMS）及应用开发工具和应用系统等。DBMS 是数据库系统的核心软件。","硬件系统#硬件系统":"硬件（Hardware）系统指存储和运行数据库系统的硬件设备，包括 CPU、内存、大容量的存储设备、输入|输出设备和外部设备等。","数据管理系统的功能#数据管理系统的功能":"数据由数据管理系统统一管理和控制。数据库管理系统提供下述 4 个方面的数据控制功能。\n数据的安全性（Security）控制：防止不合法使用数据库造成数据的泄露和破坏，使每个用户只能按规定对某些数据进行某种或某些操作和处理，保证数据的安全。\n数据的完整性（Integrity）控制：系统通过设置一些完整性规则等约束条件，确保数据的正确性、有效性和相容性。\n正确性是指数据的合法性，如年龄属于数值型数据，只能含有 0，1，…，9，不能含有字母或特殊符号。\n有效性是指数据是否在其定义的有效范围，如月份只能用 1 ～ 12 的正整数表示。\n相容性是指表示同一事实的两个数据应相同，否则就不相容，如一个人不能有两个性别。\n并发（Concurrency）控制：多个用户同时存取或修改数据库时，系统可防止由于相互干扰而提供给用户不正确的数据，并防止数据库受到破坏。\n数据恢复（Recovery）：由于计算机系统的硬件故障、软件故障、操作员的误操作及其他故意的破坏等原因，造成数据库中的数据不正确或数据丢失时，系统有能力将数据库从错误状态恢复到最近某一时刻的正确状态。","数据库系统的特点#数据库系统的特点":"数据结构化\n数据的共享性高，冗余度低且易扩充\n数据独立性高\n数据由数据库管理系统统一管理和控制\n易扩展","数据库模式结构#数据库模式结构":"逻辑数据库与物理数据库一般不一样，操作者负责弄清逻辑数据库的数据存放，操作系统负责衔接逻辑数据库与物理数据库的关系，将数据存储在硬盘上。","数据库系统的三级模式结构#数据库系统的三级模式结构":"模式。模式也称为概念模式，是数据库中全体数据的逻辑结构和特征的描述，处于三级模式结构的中间层，不涉及数据的物理存储细节和硬件环境，与具体的应用程序、所使用的应用开发工具及高级程序设计语言无关。一个数据库只有一个模式，因为它是整个数据库数据在逻辑上的视图，即是数据库的整体逻辑。\n外模式。外模式（External Schema）又称为子模式（Subschema）或用户模式（User Schema），外模式是三级结构的最外层，是数据库用户能看到并允许使用的那部分数据的逻辑结构和特征的描述，是与某一应用有关的数据的逻辑表示，也是数据库用户的数据视图，即用户视图。可见，外模式一般是模式的子集，一个数据库可以有多个外模式。由于不同用户的需求可能不同，因此，不同用户对应的外模式的描述也可能不同。外模式是保证数据库安全性的一个有力措施。\n内模式。内模式（Internal Schema）又称存储模式（Storage Schema）或物理模式（Physical Schema），是三级结构中的最内层，也是靠近物理存储的一层，即与实际存储数据方式有关的一层。它是对数据库存储结构的描述，是数据在数据库内部的表示方式。例如，记录以什么存储方式存储（顺序存储、B+ 树存储等）、索引按照什么方式组织、数据是否压缩、是否加密等，它不涉及任何存储设备的特定约束，如磁盘磁道容量和物理块大小等。\n数据库系统的三级模式是数据的三个抽象级别，它使用户能逻辑地处理数据，而不必关心数据在计算机内部的存储方式，把数据的具体组织交给 DBMS 管理。为了能够在内部实现这三个抽象层次的联系和转换，DBMS 在三级模式之间提供了二级映像功能。正是这两级映像保证了数据库系统中的较高的数据独立性，即 逻辑独立性 与 物理独立性。","数据库的二级映射#数据库的二级映射":"外模式|模式映射。模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构。数据库中的同一模式可以有任意多个外模式，对于每一个外模式，都存在一个外模式|模式映射。它确定了数据的局部逻辑结构与全局逻辑结构之间的对应关系。例如，在学生的逻辑结构（学号，姓名，性别）中添加新的属性“出生日期”时，学生的逻辑结构变为（学号，姓名，性别，出生日期），由数据库管理员对各个外模式|模式映射作相应改变，这一映射功能保证了数据的局部逻辑结构不变（即外模式保持不变）。由于应用程序是依据数据的局部逻辑结构编写的，所以应用程序不必修改，从而保证了数据与程序间的逻辑独立性。\n模式|内模式映射。数据库中的模式和内模式都只有一个，所以模式|内模式映射是唯一的。它确定了数据的全局逻辑结构与存储结构之间的对应关系。存储结构变化时，如采用了更先进的存储结构，由数据库管理员对模式|内模式映射作相应变化，使其模式仍保持不变，即把存储结构的变化影响限制在模式之下，这使数据的存储结构和存储方法较高地独立于应用程序，通过映射功能保证数据存储结构的变化不影响数据的全局逻辑结构的改变，从而不必修改应用程序，即确保了数据的物理独立性。\n这样存放数据的模式的优点：\n保证数据的独立性。将模式和内模式分开，保证了数据的物理独立性；将外模式和模式分开，保证了数据的逻辑独立性。\n简化了用户接口。按照外模式编写应用程序或输入命令，而不需了解数据库内部的存储结构，方便用户使用系统。\n有利于数据共享。在不同的外模式下可由多个用户共享系统中的数据，减少了数据冗余。\n有利于数据的安全保密。在外模式下根据要求进行操作，只能对限定的数据操作，保证了其他数据的安全。","数据库建立与基本流程#数据库建立与基本流程":"需求分析\n根据不同需求采用合理数据架构，建立合适且足够多的数据表空间\n概念设计\n设计主键等各个表之间的联系，创建各数据表之间的关系及关系表，各表对应关系也需要存储\n逻辑设计\n将数据按照日常逻辑合理展示为总表，以更符合人性的方式整理展示数据表（映射）\n转换成逻辑模型\n按照上一步的实际需求转换模型\n物理模型\n考虑索引、聚簇等细节","dbms#DBMS":"","什么是-dbms#什么是 DBMS":"DBMS 是位于用户和操作系统之间的一个系统软件。\nDBMS 是由许多程序所组成的一个大型软件系统，每个程序都有自己的功能，共同完成 DBMS 的一个或几个工作。一个完整的 DBMS 通常应由语言编译处理程序、系统运行控制程序及系统建立、维护程序和数据字典等部分组成。","dbms-的功能#DBMS 的功能":"数据定义功能：DBMS 提供数据定义语言（Data Define Language，DDL），定义数据的模式、外模式和内模式三级模式结构，定义模式|内模式和外模式|模式二级映像，定义有关的约束条件。\n数据操纵功能：DBMS 提供数据操纵语言（Data Manipulation Language，DML）实现对数据库的基本操作，包括检索、更新（包括插入、修改和删除）等。因此，DBMS 也应包括 DML 的编译程序或解释程序。\n数据库运行管理功能：对数据库的运行进行管理是 DBMS 运行的核心部分。DBMS 通过对数据库的控制以确保数据正确有效和数据库系统的正常运行。\n数据库的建立和维护功能：数据库的建立包括数据库的初始数据的装入与数据转换等，数据库的维护包括数据库的转储、恢复、重组织与重构造、系统性能监视与分析等。\n数据通信接口：DBMS 提供与其他软件系统进行通信的功能，实现用户程序与 DBMS、DBMS 与 DBMS、DBMS 与文件系统之间的通信。\n数据组织、存储和管理：DBMS 负责对数据库中需要存放的各种数据（如数据字典、用户数据、存取路径等）的组织、存储和管理工作，确定以何种文件结构和存取方式物理地组织这些数据，以提高存储空间利用率和对数据库进行增、删、查、改的效率。"}},"/02-relation-db-sys":{"title":"第 2 章 关系数据库","data":{"":"Relational schema: The simplest yet most important data model.\nInformation systems deal with storage and retrieval of data 信息系统处理数据的存储和检索\nDatabases represent a whole collection of elements 数据库是所有元素的集合\nRelations are sets of tuples 关系的元组集\nsuitable to represent collections of data of any size\ncan be illustrated(说明) by tables","关系的形式化定义#关系的形式化定义":"A relation schema provides an abstract description of the tuples(元组) in a relation 关系架构提供关系中的元组的抽象描述","域domain#域（Domain）":"域是一组具有相同数据类型的值的集合，又称为值域（用 D 表示）。例如，整数、实数和字符串的集合都是域。域中所包含的值的个数称为域的基数（用 m 表示）。在关系中就是用域来表示属性的取值范围的。","笛卡儿积cartesian-product#笛卡儿积（Cartesian Product）":"给定一组域 （它们可以包含相同的元素，既可以完全不同，也可以部分或全部相同），则  的笛卡儿积为：由定义可以看出，笛卡儿积也是一个集合，一个二维表。其中：\n每一个元素  中的每一个值  叫做一个分量（Component），分量来自相应的域（）。\n每一个元素  叫做一个 n 元组（n-Tuple），简称元组（Tuple）。但元组是有序的，相同分量  的不同排序所构成的元组不同。如，以下三个元组是不同的，。\n若  为有限集， 中的集合元素个数称为  的基数，用  表示，则笛卡儿积  的基数 M［即元组  的个数］为所有域的基数的累乘之积，即  。\n换句话说就是 A 表每一项与 B 表相接。","关系relation#关系（Relation）":"笛卡儿积  的任一子集称为定义在域  上的 n 元关系（Relation），可用  表示。其中，R 表示关系的名字，n 是关系的目或度（Degree）。\n在关系 R 中，当  时，称为单元关系。当  时，称为二元关系，以此类推。\n关系中的每个元素是关系中的元组，通常用 t 表示，关系中元组个数是关系的基数。\n如果一个关系的元组个数是无限的，则称为无限关系；如果一个关系的元组个数是有限的，则称为有限关系。由于计算机存储系统的限制，我们一般不去处理无限关系，而只考虑有限关系。\n由于关系是笛卡儿积的子集，因此，也可以把关系看成一个二维表。其中：\n表的框架由域  构成，即表的每一列对应一个域；\n表的每一行对应一个元组；\n由于不同域（列）的取值可以相同，为了加以区别，必须对每个域（列）起一个名字，称为属性（Attribute），n 元关系必有 n 个属性，属性的名字唯一；属性的取值范围称为值域，等价于对应域  的取值范围；\n具有相同关系框架的关系称为同类关系。\n在数学上，关系是笛卡儿积的任意子集，但在实际应用中，关系是笛卡儿积中所取的有意义的子集。\n定义在域  （不要求完全相异）上的关系由关系头（Heading）和关系体（Body）组成。\n关系头由属性名  的集合组成，每个属性  对应一个域 。关系头（关系框架）是关系的数据结构的描述，它是固定不变的。\n关系体是指关系结构中的内容或者数据，它随元组的插入、删除或修改而变化。","关系的性质#关系的性质":"列是同质的，即每一列中的分量必须来自同一个域，必须是同一类型的数据。\n不同的属性可来自同一个域，但不同的属性必须有不同的名字。\n列的顺序可以任意交换。但交换时，应连同属性名一起交换，否则将得到不同的关系。\n关系中元组的顺序（即行序）可任意，在一个关系中可以任意交换两行的次序。因为关系是以元组为元素的集合，而集合中的元素是无序的，所以作为集合元素的元组也是无序的。\n根据关系的这个性质，可以改变元组的顺序使其具有某种排序，然后按照顺序查询数据，这样可以提高查询速度，如按照学号对元组进行排序等。\n关系中不允许出现相同的元组。因为数学上集合中没有相同的元素，而关系是元组的集合，所以作为集合元素的元组应该是唯一的。\n关系中每一分量必须是不可分的数据项，或者说所有属性值都是原子的，即是一个确定的值，而不是值的集合。属性值可以为空值，表示“未知”或“不可使用”，但不可“表中有表”。满足此条件的关系称为规范化关系，否则称为非规范化关系。","关系模式#关系模式":"关系的描述称为关系模式（Relation Schema）。它可以形式化地表示为：其中， 为关系名； 为组成该关系的属性名集合； 为属性组  中属性所来自的域； 为属性向域的映像集合； 为属性间数据的依赖关系集合。在书写过程中，一般用下划线表示出关系中的主码。由于属性间的数据依赖  将在后面中进行讨论，而域名  及属性向域的映像  常常直接说明为属性的类型、长度。因此，关系模式通常还可简记为：其中，R 为关系名；U 为属性名的集合； 为各属性名。","关系数据库与关系数据库模式#关系数据库与关系数据库模式":"在关系模型中，实体以及实体间的联系都是用关系来表示的。在一个给定的应用领域中，所有实体以及实体之间联系所对应的关系的集合构成一个关系数据库。关系数据库的型称为关系数据库模式，是对关系数据库的描述，它包括若干域的定义以及在这些域上定义的若干关系模式。因此，关系数据库模式是对关系数据库结构的描述，或者说是对关系数据库框架的描述。","关系的码与关系的完整性#关系的码与关系的完整性":"","候选码candidate-key与超码superkey#候选码（Candidate Key）与超码（Superkey）":"候选码：能唯一标识关系中元组的一个属性或属性集，称为候选码，也称候选关键字或候选键。如“学生关系”中的学号能唯一标识每一个学生，则属性“学号”是学生关系的候选码。在“选课关系”中，只有属性的组合“学号+课程号”才能唯一地区分每一条选课记录，则属性集“学号+课程号”是选课关系的候选码。设关系  有属性 ，其属性集 ，当且仅当满足下列条件时， 被称为候选码。\n唯一性（Uniqueness），关系 R 的任意两个不同元组，其属性集 K 的值是不同的。\n最小性（Minimum），组成关系键的属性集  中，任一属性都不能从属性 集  中删掉，否则将破坏唯一性的性质。\n例如“学生关系”中的每个学生的学号是唯一的，“选课关系”中“学号+课程号”的组合也是唯一的。在属性集“学号+课程号”满足最小性，从中去掉任一属性，都无法唯一标识选课记录。超码：A superkey over a relation schema(关系模式) R is a ﬁnite subset  of R. An R-relation r is said to satisfy the superkey K over R if every pair of distinct tuples  deviates on at least one attribute of K, that is,  for some .\n在关系型数据库中，超码（Superkey）是指能够唯一标识一个元组的属性集合，而候选码（Candidate Key）是最小的超码，即不存在真子集是超码。主码（Primary Key）则是在所有候选键中选择的一个用于唯一标识关系中的元组的特定超码。因此，候选键和超码都是可以唯一标识关系中的元组的属性集合，但是候选键是最小的超码，而超码可以包含不必要的冗余属性。主键是从候选键中选择出来的一个作为主要标识符使用的特定超码。","主码primary-key#主码（Primary Key）":"如果一个关系中有多个候选码，可以从中选择一个作为查询、插入或删除元组的操作变量，被选用的候选码称为主码，或称为主关系键、主键、关系键、关键字等。例如，假设在学生关系中没有重名的学生，则“学号”和“姓名”都可作为学生关系的候选码。如果选定“学号”作为数据操作的依据，则“学号”为主码。如果选定“姓名”作为数据操作的依据，则“姓名”为主码。主码是关系模型中的一个重要概念。每个关系必须选择一个主码，选定以后，不能随意改变。因为关系的元组无重复，因此关系的所有属性的组合可以唯一标识每个元组，但通常用属性数量少的属性组合作为主码。","主属性prime-attribute与非主属性non-prime-attribute#主属性（Prime Attribute）与非主属性（Non-Prime Attribute）":"主属性（Prime Attribute）：包含在主码中的各个属性称为主属性。非主属性（Non-Prime Attribute）：不包含在任何候选码中的属性称为非主属性（或非码属性）。","外码外部关系键#外码（外部关系键）":"如果关系  的一个或一组属性  不是  的主码，而是另一关系  的主码，则该属性或属性组  称为关系  的外码（Foreign key）或外部关系键（在后续章节中统一称为外码），并称关系 R2 为参照关系（Referencing Relation），关系 R1 为被参照关系（Referenced Relation）。如之前提到的选课关系中，“学号”属性与学生关系的主码“学号”相对应，“课程外号”属性与课程关系的主码“课程号”相对应。因此，“学号”和“课程号”属性是选课关系的码。学生关系和课程关系为被参照关系，选课关系为参照关系。由外码的定义可知，被参照关系的主码和参照关系的外码必须定义在同一个域上。Example:Foreign keys on Director(id, title, year) are:\n:\nthe id of a director identiﬁes a unique person\n:\nthe title and year of a director identify a unique movie\nMovie(title, year, country) with key {title, year};\nActor(id, title, year, role) with:\nkey {id, title, year, role} and\nforeign key \n（反例）The foreign key does not permit the same databases as the two inclusion dependencies:\n and","关系的完整性#关系的完整性":"关系模型中，有三类完整性约束，即实体完整性、参照完整性和用户自定义的完整性。其中，实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作关系的两个不变性。任何关系数据库系统都应该支持这两类完整性。实体完整性（Entity Integrity）：实体完整性是指主码的值不能为空或部分为空。如学生关系中的主码“学号”不能为空，选课关系中的主码“学号+课程号”不能部分为空，即“学号”和“课程号”两个属性都不能为空。参照完整性（Referential Integrity）：如果关系  的外码  与关系  的主码相符，则  的每个值或者等于  中主码的某一个值或者取空值。它指的是 在关系型数据库中，一个表中的外键必须引用另一个表的主键，而且这种引用必须是有效的。 具体地说，这意味着如果两个表之间有外键约束，那么在插入、更新和删除数据时必须遵守一些规则：\n插入：插入数据时，必须确保外键引用的主键数据已经存在。\n更新：更新包含外键的记录时，必须确保新值是有效的主键值。否则，更新就会失败。\n删除：删除包含主键的记录时，必须确保在关联表中没有相应的外键，否则删除操作就会失败。\n参照完整性可以帮助确保数据的一致性和完整性，避免了在关联表之间不一致的情况发生。用户自定义完整性（User-defined Integrity）：用户自定义完整性是针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求。关系模型应该提供定义和检验这类完整性的机制，以便用统一的、系统的方法处理它们，而不要由应用程序承担这一功能。Integrity constraints greatly determine the design of a database schema\nto process most common queries(查询) efficiently, and\nto process most common updates efficiently, but\nin many cases compromises(妥协) are necessary","关系代数#关系代数":"讲这个前，请允许我插入一个概念。\n关系数据库的三种基本操作和语言：\n关系代数\n关系演算\nSQL 查询语句\n展开来说：\n关系代数和关系演算是两种操作关系数据库的数学表示方法。关系代数是通过一组操作来描述数据查询和转换的数学理论，如并、交、差、选择和投影等。\n关系演算则是通过描述需要从关系中获取什么样的数据来进行查询。它可以分为元组关系演算和域关系演算两种形式。\nSQL（Structured Query Language）是一种通用的关系数据库管理系统（RDBMS）的查询语言，被广泛应用于各种类型的关系型数据库。它包括数据查询、数据插入、更新和删除等多种操作。\n早期的关系操作能力通常用代数方式或逻辑方式来表示，分别称为关系代数和关系演算。\n关系代数用对关系的运算来表达查询要求。\n关系演算用谓词来表达查询要求。关系演算又可按谓词变元的基本对象是元组变量还是域变量分为元组关系演算和域关系演算。\n三种运算语言在表达能力上是等价的。","关系代数的分类及其运算符#关系代数的分类及其运算符":"关系代数是一种抽象的查询语言，是关系数据操纵语言的一种传统表达方式，它是由关系的运算来表达查询的。任何一种运算都是将一定的运算符作用于一定的运算对象上，得到预期的运算结果。所以，运算对象、运算符和运算结果是运算的三大要素。关系代数的运算对象是关系，运算结果也是关系。关系代数用到的运算符主要包括以下四类：\n集合运算符：（并）、（差）、（交）、（广义笛卡儿积）。\n专门的关系运算符：（选取）、（投影）、 （θ 连接）、（自然连接）、（除）。\n算术比较运算符：（大于）、（大于等于）、（小于）、（小于等于）、（等于）、 （不等于）。\n逻辑运算符有：（与）、（或）、（非）。\n关系代数的运算按运算符的不同主要分为以下两类：\n传统的集合运算：该类运算把关系看成元组的集合，以元组作为集合中的元素来进行运算，其运算是从关系的“水平”方向即行的角度进行的。它包括并、差、交和笛卡儿积等运算。（翻译：高中学过的那些运算）\n专门的关系运算：该类运算不仅涉及行运算（水平方向），也涉及列运算（垂直方向），这 种运算是为数据库的应用而引进的特殊运算。它包括选取、投影、连接和除法等运算。（翻译：后面新学的运算）","传统的集合运算#传统的集合运算":"设给定两个关系 R，S，若满足：\n具有相同的列数（或称度数）n；\nR 中第 i 个属性和 S 中第 i 个属性必须来自同一个域（列同质）。\n则说关系 R，S 是相容的。除笛卡儿积运算外，其他的集合运算要求参加运算的关系必须满足上述的相容性定义。\n并（Union）关系 R 和关系 S 的并运算结果由属于 R 或属于 S 的元组组成，即 R 和 S 的所有元组合并，删去重复元组，组成一个新关系，其结果仍为 n 元关系。记作：上式中，“∪”为并运算符；t 为元组变量；“∨”为逻辑或运算符。对于关系数据库，记录的插入和添加可通过并运算实现。\n差（Difference）关系 R 与关系 S 的差运算结果由属于 R 而不属于 S 的所有元组组成，即 R 中删去与 S 中相同的元组，组成一个新关系，其结果仍为 n 元关系。记作：上式中，“−”为差运算符；t 为元组变量；“∧”为逻辑与运算符；“┐”为逻辑非运算符。通过差运算，可实现关系数据库记录的删除。\n交（Intersection）关系 R 与关系 S 的交运算，结果由既属于 R 又属于 S 的元组（即 R 与 S 中相同的元组）组成一个新关系，其结果仍为 n 元关系。记作：上式中，“∩”为交运算符；t 为元组变量；“∧”为逻辑与运算符。 如果两个关系没有相同的元组，那么它们的交为空。 两个关系的并和差运算为基本运算（即不能用其他运算表达的运算），而交运算为非基本运算，交运算可以用差运算来表示： R∩S = R − (R −S)\n广义笛卡儿积（Extended Cartesian Product）个分别为 n 元和 m 元的关系 R 和 S 的广义笛卡儿积是一个  列的元组的集合，元组的前 n 列是关系 R 的一个元组，后 m 列是关系 S 的一个元组。若 R 有  个元组，S 有  个元组，则关系 R 和关系 S 的广义笛卡儿积有  个元组，记作：关系的广义笛卡儿积可用于两关系的连接操作（连接操作将在下一节中介绍）。","专门的关系运算#专门的关系运算":"由于传统的集合运算，只是从行的角度进行，而要灵活地实现关系数据库多样的查询操作，必须引入专门的关系运算。\n选取（Selection）选取运算是单目运算，它根据一定的条件从关系 R 中选择若干个元组，组成一个新关系，记作：其中，σ 为选取运算符；F 为选取的条件，它是由运算对象（属性名、常数、简单函数）、算术比较运算符（＞、≥、＜、≤、=、≠）和逻辑运算符（∨、∧、┐）连接起来的逻辑表达式，结果为逻辑值“真”或“假”。选取运算实际上是从关系 R 中选取使逻辑表达式 F 为真的元组，是从行的角度进行的运算。如：查询计算机系的全体学生（其中 5 为属性 Dept 的序号）。\nSNo\tSN\tSex\tAge\tDept\tS1\t赵亦\t女\t17\t计算机\tS5\t周武\t男\t19\t计算机\t\n又如：查询工资高于 1000 元（不包括 1000 元）的男教师。\nTNo\tTN\tSex\tAge\tProf\tSal\tComm\tDept\tT1\t李力\t男\t47\t教授\t1500\t3000\t计算机\t\n投影（Projection）投影运算也是单目运算，关系 R 上的投影是从 R 中选择出若干属性列，组成新的关系，即对关系在垂直方向进行的运算，从左到右按照指定的若干属性及顺序取出相应列，删去重复元组。记作：如：查询讲授 C5 课程的教师号。本例中采用选取运算和投影运算相结合的方式，先在授课表 TC 中选取满足条件的元组，然后在 TNo 属性上进行投影。\nNo\tT2\tT3\tT5\t\nθ 连接（θJoin）（这个好像不要求掌握）θ 连接运算是二目运算，是从两个关系的笛卡儿积中选取满足连接条件的元组，组成新的关系。设有两个关系  及 ，连接属性集  包含于 ， 包含于 ， 与  中属性列数目相等，且对应属性有共同的域。若 （/X 表示去掉 X 之外的属性）及 ，则 R 及 S 可表示为 ，；关系 R 和 S 在连接属性 X 和 Y 上的 θ 连接，就是在 R×S 笛卡儿积中，选取 X 属性 列上的分量与 Y 属性列上的分量满足 θ 比较条件的那些元组，也就是在 R×S 上选取在连接属性 X， Y 上满足 θ 条件的子集组成新的关系。新关系的列数为 n+m，记作：其中，  是连接运算符；θ 为算术比较运算符，也称 θ 连接。XθY 为连接条件，其中：\nθ 为“=”时，称为等值连接；\nθ 为“＜”时，称为小于连接；\nθ 为“＞”时，称为大于连接。\n自然连接在连接运算中，一种最常用的连接是自然连接。所谓自然连接就是在等值连接的情况下，当连接属性 X 与 Y 具有相同属性组时，把在连接结果中重复的属性列去掉。即如果 R 与 S 具有相同的属性组 Y，则自然连接可记作：自然连接是在广义笛卡儿积 R×S 中选出同名属性上符合相等条件的元组，再进行投影，去掉重复的同名属性，组成新的关系。等值连接与自然连接的区别：\n等值连接中不要求相等属性值的属性名相同，而自然连接要求相等属性值的属性名必须相同，即两关系只有同名属性才能进行自然连接。\n在连接结果中，等值连接不将重复属性去掉，而自然连接去掉重复属性，也可以说，自然连接是去掉重复列的等值连接。\n除法（Division）除法运算是二目运算，设有关系 R（X，Y）与关系 S（Y，Z），其中 X，Y，Z 为属性集合，R 中的 Y 与 S 中的 Y 可以有不同的属性名，但对应属性必须出自相同的域。关系 R 除 以关系 S 所得的商是一个新关系 P（X），P 是 R 中满足下列条件的元组在 X 上的投影：元组在 X 上 分量值 x 的像集  包含 S 在 Y 上投影的集合。记作：其中， 为 x 在 R 中的像集，。如：已知关系 R 和 S，如图 2-11（a）和图 2-11（b）所示，则 R÷S 如图 2-11（c）所示。与除法的定义相对应，本题中 ，，。其中，元组在 X 上各个分量值的像集分别为：\n 的像集为 \n 的像集为 \n 的像集为 \nS 在 Y 上的投影为 \n显然只有  的像集包含 S 在 Y 上的投影，所以 。除法运算同时从行和列的角度进行运算，适合于包含“全部”之类的短语的查询。又如：查询选修了全部课程的学生学号和姓名。","关系演算#关系演算":"关系演算是一种非过程查询语言，它告诉系统要检索哪些数据但不告诉如何检索它。关系演算是以数理逻辑中的谓词演算为基础，通过谓词形式来表示查询表达式。根据谓词变元的不同，可将关系演算分为元组关系演算和域关系演算。\n数据库学习摘记 —— 关系代数和关系演算 - 咕~咕咕 - 博客园 (cnblogs.com)关系运算的安全限制：无限关系：当元组变元 t 中某一属性的定义域是无限时，如表示所有不在关系 R 中的元组的集合 。无穷验证过程：t 的取值范围为无限，如验证  为真的过程。安全表达式：不产生无限关系和无穷验证过程的表达式。安全限制：为保证所有表达式都是安全表达式所采取的限制措施。关系代数运算是安全的：当给定的所有关系是有限时，其运算的有限次复合不会出现无限关系和无穷验证。等价：关系代数、安全的元组关系演算和安全的域关系演算的表达能力是等价的，可以相互转换。","元组关系演算trc#元组关系演算（TRC）":"参考自 Tuple Relational Calculus (TRC) in DBMS - GeeksforGeeks，有删改。Tuple Relational Calculus (元组关系演算，也可以简称 TRC) is a non-procedural query language(非过程查询语言) used in relational database management systems (关系数据库管理系统 RDBMS) to retrieve data(检索数据) from tables. TRC is based on the concept of tuples(基于元组的概念), which are ordered sets of attribute values(是一组有序的属性值) that represent a single row or record in a database table.TRC is a declarative language, meaning that it specifies what data is required from the database, rather than how to retrieve it. TRC queries are expressed as logical formulas that describe the desired tuples. TRC 是一种声明性语言，这意味着它指定需要从数据库中获取哪些数据，而不是如何检索这些数据。TRC 查询表示为描述所需元组的逻辑公式。The basic syntax(基本语法) of TRC is as follows:where t is a tuple variable and P(t) is a logical formula that describes the conditions that the tuples in the result must satisfy(描述结果中的元组必须满足的条件的逻辑公式). The curly braces {} are used to indicate(指示) that the expression is a set of tuples. 其中 t 是元组变量，P(t) 是描述结果中的元组必须满足的条件的逻辑公式。花括号 {} 用于指示表达式是一组元组。It also uses quantifiers(量词):It means ”there exists” a tuple in t in relation r such that predicate Q(t) is true. And  is true “for all” tuples in relation r.For example, let’s say we have a table called “Employees” with the following attributes:\nEmployeeID\nName\nSalary\nDepartmentID\nTo retrieve(检索) the names of all employees who earn more than $50,000 per year, we can use the following TRC query:In this query, the “Employees(t)” expression specifies(指定) that the tuple variable t represents a row in the “Employees” table. The “∧” symbol is the logical AND operator, which is used to combine the condition “t.Salary > 50000” with the table selection. 在此查询中，“Employees(t)”表达式指定元组变量 t 表示“Employees”表中的一行。 “∧”符号是逻辑与运算符，用于将条件“t.Salary > 50000”与表选择结合起来。The result of this query will be a set of tuples, where each tuple contains the Name attribute of an employee who earns more than $50,000 per year. 此查询的结果将是一组元组，其中每个元组包含年收入超过 50,000 美元的员工的 Name 属性。TRC can also be used to perform more complex queries, such as joins and nested queries, by using additional logical operators and expressions. 通过使用额外的逻辑运算符和表达式，TRC 还可用于执行更复杂的查询，例如连接和嵌套查询。While TRC is a powerful query language, it can be more difficult to write and understand than other SQL-based query languages, such as Structured Query Language (SQL). However, it is useful in certain applications, such as in the formal verification of database schemas and in academic research. 虽然 TRC 是一种功能强大的查询语言，但它比其他基于 SQL 的查询语言（例如结构化查询语言 (SQL)）更难编写和理解。但是，它在某些应用程序中很有用，例如数据库模式的形式验证和学术研究。Tuple Relational Calculus is a non-procedural query language unlike relational algebra. Tuple Calculus provides only the description of the query but it does not provide the methods to solve it. Thus, it explains what to do but not how to do. 与关系代数不同，元组关系演算是一种非过程查询语言。元组微积分仅提供查询的描述，但不提供解决问题的方法。因此，它解释了做什么而不是如何做。\n如：\nFirst_Name\tLast_Name\tAge\tAjeet\tSingh\t30\tChaitanya\tSingh\t31\tRajeev\tBhatia\t27\tCarl\tPratap\t28\t\n查询来显示年龄大于 30 岁的学生的姓氏。\nLast_Name\tSingh\t\n查询来显示姓氏为\"Singh\"的学生的所有详细信息。\nFirst_Name\tLast_Name\tAge\tAjeet\tSingh\t30\tChaitanya\tSingh\t31","域关系演算drc#域关系演算（DRC）":"在域关系演算中，记录基于域进行过滤。Domain Relational Calculus is a non-procedural query language equivalent in power to Tuple Relational Calculus. Domain Relational Calculus provides only the description of the query but it does not provide the methods to solve it. In Domain Relational Calculus, a query is expressed as, 域关系演算是一种非过程查询语言，其功能等同于元组关系演算。域关系演算仅提供查询的描述，但不提供解决问题的方法。在域关系演算中，查询表示为，where,  represents resulting domains variables(结果域变量) and  represents the condition or formula equivalent to the Predicate calculus(Predicate 演算的条件或公式).Predicate Calculus Formula 谓词演算公式：\nSet of all comparison operators 所有比较运算符的集合\nSet of connectives(连接词) like and, or, not\nSet of quantifiers 量词集\n如：Loan 表：\nLoan number\tBranch name\tAmount\tL01\tMain\t200\tL03\tMain\t150\tL10\tSub\t90\tL08\tMain\t60\t\nBorrower 表：\nCustomer name\tLoan number\tRitu\tL01\tDebomit\tL08\tSoumya\tL03\t\nFind the loan number, branch, amount of loans of greater than or equal to 100 amount.\nLoan number\tBranch name\tAmount\tL01\tMain\t200\tL03\tMain\t150\t\nFind the names of all customers having a loan at the “Main” branch and find the loan amount.\nCustomer Name\tAmount\tRitu\t200\tDebomit\t60\tSoumya\t150\t\nThe domain variables(域变量) those will be in resulting relation(结果关系) must appear before | within < and > and all the domain variables must appear in which order they are in original relation or table 所有域变量必须按照它们在原始关系或表中的顺序出现.","difference-between-trc-and-drc#Difference between TRC and DRC":"参考自 Difference between Tuple Relational Calculus (TRC) and Domain Relational Calculus (DRC) - GeeksforGeeks，有删改。\nTuple Relational Calculus (TRC):A tuple relational calculus is a non-procedural query language(非过程查询语言) that specifies to select of the tuples in a relation. It can select the tuples with a range of values or tuples for certain attribute values(某些属性值) etc. The resulting relation can have one or more tuples.公式：where T is the resulting tuples and P(T) is a condition used to fetch T.\nDomain Relational Calculus (DRC):A domain relational calculus uses the list of attributes(属性列表) to be selected from the relation based on the condition. It is the same as TRC but differs by selecting the attributes rather than selecting whole tuples.公式：\n一图流表格：\nBasis of Comparison\tTuple Relational Calculus (TRC)\tDomain Relational Calculus (DRC)\tDefinition\tThe Tuple Relational Calculus (TRC) is used to select tuples from a relation. The tuples with specific range values, tuples with certain attribute values, and so on can be selected. 可以选择具有特定范围值的元组、具有特定属性值的元组等。\tThe Domain Relational Calculus (DRC) employs a list of attributes from which to choose based on the condition. It’s similar to TRC, but instead of selecting entire tuples, it selects attributes. 它类似于 TRC，但它不是选择整个元组，而是选择属性。\tRepresentation(表示) of variables\tIn TRC, the variables represent the tuples from specified relations(指定关系中的元组).\tIn DRC, the variables represent the value drawn from a specified domain(从指定域中提取的值).\tTuple/ Domain\tA tuple is a single element of relation. In database terms, it is a row.\tA domain is equivalent to column data type and any constraints on the value of data. 域等同于列数据类型和对数据值的任何约束。\tFiltering\tThis filtering variable uses a tuple of relations. 此过滤变量使用关系元组。\tThis filtering is done based on the domain of attributes. 这种过滤是基于属性域完成的。\tReturn Value\tThe predicate expression condition associated with the TRC is used to test every row using a tuple variable and return those tuples that met the condition. 与 TRC 关联的谓词表达式条件用于使用元组变量测试每一行并返回满足条件的那些元组。\tDRC takes advantage of domain variables and, based on the condition set, returns the required attribute or column that satisfies the criteria of the condition. DRC 利用域变量，并根据条件集返回满足条件条件的所需属性或列。\tMembership condition\tThe query cannot be expressed using a membership condition. 不能使用成员资格条件来表达查询。\tThe query can be expressed using a membership condition. 可以使用成员资格条件来表达查询。\tQuery Language\tThe QUEL or Query Language is a query language related to it.\tThe QBE or Query-By-Example is query language related to it.\tSimilarity\tIt reflects traditional pre-relational file structures. 它反映了传统的前关系文件结构。\tIt is more similar to logic as a modeling language. 作为一种建模语言，它更类似于逻辑。\tSyntax\t{T | P (T)} or {T | Condition (T)}\t{ a1, a2, a3, …, an | P (a1, a2, a3, …, an)}\tExample\t{T | EMPLOYEE (T) AND T.DEPT_ID = 10}\t{ | < EMPLOYEE > DEPT_ID = 10 }\tFocus\tFocuses on selecting tuples from a relation\tFocuses on selecting values from a relation\tVariables\tUses tuple variables (e.g., t)\tUses scalar variables(标量变量) (e.g., a1, a2, …, an)\tExpressiveness\tLess expressive\tMore expressive\tEase of use\tEasier to use for simple queries.\tMore difficult to use for simple queries.\tUse case\tUseful for selecting tuples that satisfy a certain condition or for retrieving a subset of a relation. 对于选择满足特定条件的元组或检索关系的子集很有用。\tUseful for selecting specific values or for constructing more complex queries that involve multiple relations. 对于选择特定值或构建涉及多个关系的更复杂的查询很有用。","summary#Summary":"Relational DBMSs are based on the relational data model\nThe relational data model is formally deﬁned, its properties can be proven, explained and justiﬁed, and formal query languages such as relational calculus and algebra have been deﬁned on it.\nThe most important concepts in the relational data model are:\nsyntactic level: attributes, relation schemata, database schemata\nsemantic level: domains, tuples, relations, databases\nIntegrity constraints play an important part in schema design\ndetermine efficiency of updates\ndetermine efficiency of queries\nDBMSs oﬀer support for enforcement of some constraints\ndomain constraints, key constraints, foreign key constraints"}},"/04-relation-db-theory":{"title":"第 4 章 关系数据库理论","data":{"":"前面已经讲述了关系数据库、关系模型的基本概念以及关系数据库的标准语言。如何使用关系模型设计关系数据库，也就是面对一个现实问题，如何选择一个比较好的关系模式的集合，每个关系又应该由哪些属性组成，这属于数据库设计的问题，确切地讲是数据库逻辑设计的问题。设计关系数据库的步骤：\n需求分析（现实世界用户需求）\n概念设计（如画 E-R 图，设计实体与实体关系、属性）\n逻辑设计（实体转化为对应表）\n物理设计（考虑索引，并转换为 SQL 语句）\n规范化是在逻辑设计这个阶段提出的。","规范化问题的提出#规范化问题的提出":"关系数据库的规范化理论主要包括三个方面的内容：函数依赖、范式（Normal Form）和模式设计。其中函数依赖起着核心的作用，是模式分解和模式设计的基础，范式是模式分解的标准。\n针对具体问题，应该如何构造一个适合于它的数据库模式，即应该构造几个关系模式，每个关系由哪些属性组成等。\n人们以关系模型为背景讨论这个问题，形成了数据库逻辑设计的工具——关系数据库的规范化理论。\n如：要求设计教学管理数据库，其关系模式 SCD 如下：其中，SNo 表示学生学号，SN 表示学生姓名，Age 表示学生年龄，Dept 表示学生所在的系别，MN 表示系主任姓名，CNo 表示课程号，Score 表示成绩。根据实际情况，SCD 的这些数据具有如下语义规定：\n一个系有若干名学生，但一名学生只属于一个系；\n一个系只有一名系主任，但一名系主任可以同时兼几个系的系主任；\n一名学生可以选修多门功课，每门课程可被若干名学生选修；\n每名学生学习的课程有一个成绩，但不一定立即给出。\n在此关系模式中填入一部分具体的数据，则可得到 SCD 关系模式的实例，即一个教学管理数据库。根据上述的语义规定分析以上教学管理数据库，可以看出，（SNo，CNo）属性的组合能唯一标识一个元组，即可以通过（SNo，CNo）的取值分辨不同学生记录，所以（SNo，CNo）是该关系模式的主码。若使用上述数据库建立教学管理信息系统，则会出现以下几方面的问题：\n数据冗余。每个系名和系主任名字的存储次数等于该系学生人数乘以每个学生选修的课程门数，同时学生的姓名、年龄也都要重复存储多次，数据的冗余度很大，浪费了存储空间。尽管很多时候有冗余反而在查询方面带来一些好处。\n插入异常。如果某个新系没有招生，尚无学生时，则系名和系主任的信息无法插入到数据库中。因为在这个关系模式中，（SNo，CNo）是主码。根据关系的实体完整性约束，任何记录的主码的值不能为空，由于该系没有学生，SNo 和 CNo 均无值，因此不能进行插入操作。另外，当某个学生尚未选课，同样也不能进行插入操作，主要原因是 CNo 未知，实体完整性约束还规定，主码的值不能部分为空。\n删除异常。当某系学生全部毕业而没有招生时，要删除全部学生的记录，这时系名、系主任也随之删除，而现实中这个系可能依然存在，但在数据库中却无法找到该系的信息。另外，如果某个学生不再选修 C1 课程，本应该只删去 C1，但 C1 是主码的一部分，为保证实体完整性，必须将整个元组一起删掉，这样，元组中有关该学生的其他信息也随之丢失。\n更新异常。如果某学生改名，则该学生的所有记录都要逐一修改 SN 的值；又如某系更换系主任，则属于该系的学生记录都要修改 MN 的内容，稍有不慎，就有可能漏改某些记录，这就会造成数据的不一致性，破坏了数据的完整性。\n由于存在以上问题，可以说，SCD 是一个不好的关系模式。产生上述问题的原因，直观地说，是因为关系中“包罗万象”，内容过于全面。我们一般把原来的关系模式 SCD 称为泛模式，泛模式用一个大表存放所有的数据。优化后，我们把关系模式 SCD 分解为学生关系 S（SNo， SN，Age，Dept）、选课关系 SC（SNo，CNo，Score）和系关系 D（Dept，MN）三个结构简单的关系模式。经过上述分析，我们说分解后的关系模式是一个规范的关系数据库模式。从而得出结论，一个规范的关系模式应该具备以下四个条件：\n尽可能少的数据冗余。\n没有插入异常。\n没有删除异常。\n没有更新异常。\n按照一定的规范设计关系模式，将结构复杂的关系分解成结构简单的关系，从而把不规范的关系数据库模式转变为规范的关系数据库模式，这就是关系的规范化。\n关系模式是一个五元组：\n关系名 R 是符号化的元组语义\nU 为一组属性\nD 为 U 中的属性所来自的域\nDOM 为属性到域的映射\nF 为 U 上的一组数据依赖","函数依赖#函数依赖":"关系模式中的各属性之间相互依赖、相互制约的联系称为数据依赖。数据依赖一般分为函数依赖和多值依赖。其中函数依赖是最重要的数据依赖。函数依赖（Functional Dependency，FD）是关系模式中属性之间的一种逻辑依赖关系。例如，在上一节的关系模式 SCD 中，SNo 与 SN、Age 和 Dept 之间都有一种逻辑依赖关系。由于一个 SNo 只 对应一个学生，而一个学生只能属于一个系，因此当 SNo 的值确定之后，该学生的 SN、Age、Dept 的值也随之被唯一地确定了。这类似于变量之间的单值函数关系。设单值函数 ，自变量 X 的值可以决定唯一的函数值 Y。同理，我们可以说 SNo 的值唯一地决定函数（SN，Age，Dept）的值，或者说（SN，Age，Dept）函数依赖于 SNo。\n设关系模式 ，U 是属性全集，F 是由 U 上函数依赖所构成的集合，X 和 Y 是 U 的子集，如果对于  的任意一个可能的关系 r，对于 X 的每一个具体值，Y 都有唯一的具体值与之对应，则称 X 决定函数 Y，或 Y 函数依赖于 X，记作 。我们称 X 为决定因素，Y 为依赖因素。当 Y 不函数依赖于 X 时，记作：（有个斜划线打不出来，读者知道就好）。当  且  时，则记作：。\n使用这个定义关系模式 SCD 中属性全集 U 和函数依赖集 F：有关函数依赖有以下几点需要说明。\n唯一性对于定义 “如果对于  的任意一个可能的关系 r，对于 X 的每一个具体值，Y 都有唯一的具体值与之对应”，其含义是，对于 r 的任意两个元组 t1 和 t2，只要 ，就有 。\n平凡的函数依赖与非平凡的函数依赖当属性集 Y 是属性集 X 的子集（即 ）时，则必然存在着函数依赖 ，这种类型的函数依赖称为平凡的函数依赖，如当  唯一确定的时候，它的任意子属性集合 必然唯一确定。如果 Y 不是 X 的子集，则称  为非平凡的函数依赖。平凡的函数依赖并没有实际意义，若不特别声明，我们讨论的都是非平凡的函数依赖，非平凡的函数依赖才和 “真正的” 完整性约束条件相关。\n部分依赖（P）和完全依赖（F）部分依赖指的是某个非主属性依赖于部分而不是整个候选键，而完全依赖表示非主属性完全依赖于整个候选键。如： 就是部分依赖，学生学号（SNo）部分依赖于学生姓名（SN），因为一个学生可能有多个姓名，而学号却保持不变。但  是完全依赖，学生学号（SNo）和课程号（CNo）完全依赖于成绩（Score），因为给定学生和课程的组合，成绩是唯一确定的。如果移除任何一个属性（SNo 或 CNo），就无法确定对应的成绩。\n传递函数依赖传递函数依赖是指当存在函数依赖  和  时，可以推导出  的情况。换句话说，如果通过中间属性 B 能够推导出 A 依赖于 C，那么就存在传递函数依赖。如 ，，可以推出 Mname 传递函数依赖于 Sno。\n函数依赖与属性之间的联系类型有关\n在一个关系模式中，如果属性 X 与 Y 有 1∶1 联系时，则存在函数依赖 X→Y，Y→X，即 。例如，当学生无重名时，。\n如果属性 X 与 Y 有 m∶1 的联系时，则只存在函数依赖 X→Y。例如，SNo 与 Age、Dept 之间均为 m∶1 联系，所以有 ，。\n如果属性 X 与 Y 有 m∶n 的联系时，则 X 与 Y 之间不存在任何函数依赖关系。\n由于函数依赖与属性之间的联系类型有关，因此在确定属性间的函数依赖关系时，可以从分析属性间的联系类型入手，便可确定属性间的函数依赖。","函数依赖的逻辑蕴涵定义#函数依赖的逻辑蕴涵定义":"假设已知关系模式  有 ，，问  是否成立？能否从已知的函数依赖推导出 ？设 F 是在关系模式  上成立的函数依赖集合，X，Y 是属性集 U 的子集， 是一个函数依赖。如果从 F 中能够推导出 X→Y，即如果对于 R 的每个满足 F 的关系 r 也满足 ，则称 X→Y 为 F 的逻辑蕴涵（或 F 逻辑蕴涵 X→Y），记为 。","函数依赖的推理规则及正确性#函数依赖的推理规则及正确性":"从已知的函数依赖，可以推导出另外一些新的函数依赖，这就需要一系列推理规则，函数依赖的推理规则最早出现在 1974 年 W.W.Armstrong 的论文里，这些规则常被称为“Armstrong 公理”（即阿氏公理），下面的推理规则是其他人于 1977 年对阿氏公理体系改进后的形式。设有关系模式 ，U 是关系模式 R 的属性集，F 是 R 上成立的只涉及 U 中属性的函数依赖集。X，Y，Z，W 均是 U 的子集，r 是 R 的一个实例。函数依赖的推理规则如下。","armstrong-公理及正确性#Armstrong 公理及正确性":"A1：自反律（Reflexivity）如果 ，则  在 R 上成立。即一组属性函数决定它的所有子集。\n证明：因为 ，若 r 中存在两个元组在 X 上的值相等，那么 X 的子集 Y 其值也必然相等。前 面所提到的平凡的函数依赖就可根据自反律推出。\n例如，在关系 SCD 中， 和 。\nA2：增广律（Augmentation）若  在 R 上成立，且 ，则  在 R 上也成立。证明：用反证法。\n假设 r 中存在两个元组 t1 和 t2 违反 ，即 ，但 。从  可知， 或 。如果 ，则与已知的  相矛盾；如果 ，则与假设的  相矛盾。 因此，假设不成立，从而得出增广律是正确的。\n例如：在关系 SCD 中，，则 。\nA3：传递律（Transitivity）若  和  在 R 上成立，则  在 R 上也成立。\n证明：用反证法。 假设 r 中存在两个元组 t1 和 t2 违反 ，即 ，但 。在上述假设下， 或 。如果 t1[Y]≠t2[Y]，则与已知的  相矛盾；如果 ，则与已知的  相矛盾。因此，假设不成立，从而得出传递律是正确的。\n例如：在关系 SCD 中，，，则 。","armstrong-公理推论及正确性#Armstrong 公理推论及正确性":"合并律（Union rule）若 X→Y 和 X→Z 在 R 上成立，则 X→YZ 在 R 上也成立。\n证明：对已知的 ，根据增广律，两边用 X 扩充，得到 。对已知的 ，根据增广律，两边用 Y 进行扩充，得到 。对  和 ，根据传递律，得到 。\n例如，在关系 SCD 中，，，则有 。\n伪传递律（Pseudotransitivity rule）若  和  在 R 上成立，则  在 R 上也成立。\n证明：对已知的 ，根据增广律，两边用 W 扩充，得到 。 对  和已知的 ，根据传递律，得到 。\n例如，在 SCD 中，，，则 。\n分解律（Decomposition rule）若  和  在 R 上成立，则  在 R 上也成立。\n证明：对已知的 ，根据自反律，得到 ；对已知的  和 ，再根据传递律，得到 。\n很显然，分解律和合并律互为逆过程。例如：在 SCD 中，。\n复合律（Composition）若  和  在 R 上成立，则  在 R 上也成立。\n证明：对已知的 ，根据增广律，两边用 W 扩充，得到 。对已知的 ，根据增广律，两边用 Y 扩充，得到 。对  和 ，根据传递律，得到 。\n例如，在 SCD 中，，，则有 。","闭包#闭包":"设 F 是函数依赖集，被 F 逻辑蕴涵的全部函数依赖集合，称为函数依赖集 F 的闭包 （Closure），记为 。即：求闭包（原理是 Armstrong 定理）：\n看左边，找右边（由左边子元素可以直接推出）\n右边迁到左边，继续看左边找右边，直到寻找结束\n求码：通过指定属性求出闭包为 U（全体）就算是码。但已知的关系式中只在左边的属性（推导属性）通常是码的组成部分之一（只能主动推导别人，不能被别人推导）；反过来说，只在右边出现的属性（被推导属性）通常不会是码的组成部分之一。","码#码":"在关系数据库中，码（Key）是用于唯一标识关系中元组的属性或属性组合。它在关系模型中起着至关重要的作用，用于确保关系的唯一性和识别性。主属性（Primary Attribute）：主属性是与主码直接关联的属性。主属性的取值在关系中必须是唯一的，与主码的取值一一对应。一个关系可以有多个主属性，每个主属性都直接依赖于主码。有几种类型的码可以在关系数据库中使用：\n候选码（Candidate Key）：候选码是能够唯一标识关系中元组的最小属性组合。换句话说，候选码是没有冗余属性的最小超键。一个关系可以有多个候选码，其中任意一个候选码都可以成为主码（Primary Key）。\n主码（Primary Key）：主码是从候选码中选择的一个，用于唯一标识关系中的每个元组。主码必须是候选码，且不能包含重复或空值。\n外码（Foreign Key）：外码是关系中的属性（或属性组合），它引用了另一个关系中的主码。外码用于建立关系之间的联系，实现关系数据库的关联性。外码的值必须与其所引用的主码值相匹配，或者为 NULL。\n全码（Full Key）：全码是指能够唯一标识关系中每个元组的属性或属性组合。换句话说，全码是关系中没有冗余属性的超键，它可以唯一地识别关系中的每个元组。在一个关系中，可能存在多个全码。\n全码或主码可以用下划线或者加粗等方式来标识，以示其在关系中的重要性和特殊性。","关系模式的范式#关系模式的范式":"在关系模式的分解中，函数依赖起着重要的作用，那么分解以后模式的好坏，用什么标准衡量？这个标准就是模式的范式（Normal Forms，NF）。关系模式规范化的基本思想是消除关系模式中的数据冗余，消除数据依赖中的不合适的部分，解决数据插入、删除时发生的异常现象。这就要求关系模式要满足一定的条件。把关系模式规范化过程中为不同程度的规范化要求设立的不同标准称为范式。由于规范化的程度不同，就产生了不同的范式。各个范式之间的联系可以表示为：","第一范式#第一范式":"第一范式（First Normal Form）是最基本的规范形式，即关系中每个属性都是不可再分的原子项。如果关系模式 R 所有的属性均为原子属性，即每个属性都是不可再分的，则称 R 属于第一范式，简称 1NF，记作 。1NF 是关系模式应具备的最起码的条件。在非规范化的关系中去掉组合项就能转化成规范化的关系。然而，一个关系模式仅仅属于第一范式是不够的。在上面中给出的关系模式 SCD 属于第一范式，但它具有大量的数据冗余，存在插入异常、删除异常和更新异常等弊端。为什么会存在这种问题呢？让我们分析一下 SCD 中的函数依赖关系，它的码是（SNo，CNo）的属性组合，所以有：函数依赖关系：","第二范式#第二范式":"如果关系模式 ，且每个非主属性都完全函数依赖于 R 的主码，则称 R 属于第二范式（Second Normal Form），简称 2NF，记作 。如果数据库模式中每个关系模式都是 2NF，则这个数据库模式称为 2NF 的数据库模式。在关系模式 SCD 中，SNo、CNo 为主属性，Age、Dept、SN、MN 和 Score 均为非主属性，经上述分析，存在非主属性对主码的部分函数依赖，所以 。而如图 4-2 所示的由 SCD 分解的三个关系模式 S、D 和 SC 中，S 的码为 SNo；D 的码为 Dept，它们都是单属性，不可能存在部分函数依赖。而对于 SC，。所以 SCD 分解后，消除了非主属性对主码的部分函数依赖，S、D 和 SC 均属于 2NF。由 ，，，，，可以判断，关系 SCD 至少描述了两个实体，一个为学生实体，属性有 SNo、SN、Age、Dept 和 MN；另一个是学生 与课程的选课联系，属性有 SNo、CNo 和 Score。根据分解的原则，可以将 SCD 分解成如下两个关系：1NF 的关系模式经过投影分解转换成 2NF 后，消除了一些数据冗余。分析图中 SD 和 SC 中的数据，可以看出，它们存储的冗余度比关系模式 SCD 有了较大幅度的降低，但仍然存在一些问题：\n数据冗余。如每个系名和系主任的名字存储的次数等于该系的学生人数。\n插入异常。如当一个新系没有招生时，有关该系的信息无法插入。\n删除异常。如某系学生全部毕业而没有招生时，删除全部学生的记录也随之删除了该系的有关信息。\n更新异常。如更换系主任时，仍需改动较多的学生记录。\n为此，对关系模式 SD 还需进一步简化，消除这种传递函数依赖，这样就得到了 3NF。","第三范式#第三范式":"如果关系模式 ，且每个非主属性都不传递函数依赖于 R 的主码，则称 R 属于第三范式（Third Normal Form），简称 3NF，记作 。在 SD 中，主码为 SNo，非主属性 Dept 和 MN 与主码 SNo 间存在着函数依赖  和 ，即 。可见，非主属性 MN 与主码 SNo 间存在着传递函数依赖，所以 。 对于 SD，应该进一步进行分解，使其转换成 3NF。3NF 规范化是指把 2NF 的关系模式通过投影分解转换成 3NF 关系模式的集合。3NF 规范化时遵循的原则与 2NF 相同 ，即“ 一 事一地”，让一个关系只描述一个实体或者实体间 的联系。把一个关系模式分解为 3NF，使它既具有无 损连接性，又具有保持函数依赖性。如将 SD 分解为  时，S，D 都属于 3NF， 且既具有无损连接性又具有保持函数依赖性。由以上两图可以看出，关系模式 SD 由 2NF 分解为 3NF 后，函数依赖关系变得更加简单，既没有非主属性对主码的部分函数依赖，也没有非主属性对主码的传递函数依赖，解决了 2NF 中存在的四个问题，具有以下特点。\n数据冗余降低了。如系主任的名字存储的次数与该系的学生人数无关，只在关系 D 中存储一次。\n不存在入异常。如当一个新系没有学生时，该系的信息可以直接插入到关系 D 中，而与学生关系 S 无关。\n不存在删除异常。当要删除某系的全部学生而仍然保留该系的有关信息时，可以只删除学生关系 S 中的相关学生记录，而不影响系关系 D 中的数据。\n不存在更新异常。如更换系主任时，只需修改关系 D 中一个相应元组的 MN 属性值，不会出现数据的不一致现象。\nSCD 规范到 3NF 后，所存在的异常现象已经全部消失。但是，3NF 只限制了非主属性对主码的依赖关系，而没有限制主属性对主码的依赖关系。如果发生了这种依赖，仍有可能存在数据冗余、插入异常、删除异常和修改异常。这时，则需对 3NF 进一步规范化，消除主属性对主码的依赖关系。为了解决这种问题，Boyce 与 Codd 共同提出了一个新范式的定义，这就是 Boyce-Codd 范式，通常简称 BCNF 或 BC 范式，它弥补了 3NF 的不足。","bc-范式#BC 范式":"如果关系模式 ，且所有的函数依赖 ，决定因素 X 都包含了 R 的一个候选码，则称 R 属于 BC 范式（Boyce-Codd Normal Form），记作 。如果数据库中每个关系模式都属于 BCNF，则称为 BCNF 的数据库模式。BCNF 具有如下性质：\n满足 BCNF 的关系将消除任何属性（主属性或非主属性）对主码的部分函数依赖和传递函数依赖。也就是说，如果 ，则 R 也是 3NF。\n如果 ，则 R 不一定是 BCNF。如  函数依赖：\nBCNF 规范化是指把 3NF 的关系模式通过投影分解转换成 BCNF 关系模式的集合。\n多值依赖与第四范式（4NF）考试不考，所以不写（不服打我）","关系模式的规范化#关系模式的规范化":"范式级别可以逐级升高，而升高规范化的过程就是逐步消除关系模式中不合适的数据依赖的过程，使模型中的各个关系模式达到某种程度的分离。一个低一级范式的关系模式，通过模式分解转化为若干个高一级范式的关系模式的集合，这种分解过程叫作关系模式的规范化（Normalization）。"}},"/03-data-def-lang":{"title":"第 3 章 关系数据库标准语言--SQL","data":{"":"SQL 是 Structured Query Language 的缩写，中文翻译为\"结构化查询语言\"。它是一种标准的关系型数据库管理系统（RDBMS）的语言，用于存储、管理和检索数据。尽管它被称为查询语言，但其功能包括数据查询、数据定义、数据操纵和数据控制四部分。","sql-的基本概念与特点#SQL 的基本概念与特点":"","sql-历史发展#SQL 历史发展":"历史悠久的前身阶段（1960-1970）：在关系型数据库之前，主要使用网络和层次数据库管理系统。这个时期的数据库查询语言还要针对特定数据库编写相应的语言，没有标准化的统一语言。\n标准化阶段（1970-1986）：关系型数据库得到了广泛的应用，IBM 公司推出了一种被称为 SEQUEL 的数据库语言。后来，SEQUEL 被更名为 SQL，并在 1986 年成为 ISO 的国际标准。\n发展阶段（1986-至今）：SQL 成为各种关系型数据库的标准语言，并且被广泛地应用于企业级数据管理系统中。SQL 标准持续发展，并且被越来越多的应用到数据分析和数据科学领域中。\n除了标准的 SQL，也有许多针对特定数据库或应用的语言或标准，如 MySQL 的 MySQL Query Language（MySQL 的方言）、Microsoft 的 Transact-SQL（T-SQL）等。","sql-的基本概念#SQL 的基本概念":"1．基本表（Base Table）一个关系对应一个基本表。基本表是独立存在的表，不是由其他表导出的。一个或多个基本表对应一个存储文件。2．视图（View）视图是从一个或几个基本表导出的表，是一个虚表。数据库中只存放视图的定义而不存放视图对 应的数据，这些数据仍存放在导出视图的基本表中。当基本表中的数据发生变化时，从视图查询出来的数据也随之改变。\nSQL 语句后面的分号？某些数据库系统要求在每条 SQL 命令的末端使用分号。分号是在数据库系统中分隔每条 SQL 语句的标准方法，这样就可以在对服务器的相同请求中执行一条以上的语句。如果您使用的是 MS Access 和 SQL Server 2000，则不必在每条 SQL 语句之后使用分号，不过某些数据库软件要求必须使用分号。SQL 中的大小写？SQL 不区分关键字的大小写。例如，不管写成 SELECT 还是 select，解释都是一样的。表名和列名也是如此。虽然可以根据个人喜好选择大写还是小写（或大小写混杂），但为了理解起来更加容易，可以用以下规则来书写 SQL 语句。\n关键字大写\n表名的首字母大写\n其余（列名等）小写","数据库表的创建与使用#数据库/表的创建与使用":"","一些重要的-sql-命令#一些重要的 SQL 命令":"DDL（Data Definition Language，数据定义语言）用来创建或者删除存储数据用的数据库以及数据库中的表等对象。DDL 包含以下几种指令。\nCREATE DATABASE：创建新数据库\nALTER DATABASE：修改数据库\nCREATE TABLE：创建新表\nALTER TABLE：变更（改变）数据库表\nDROP TABLE：删除表\nCREATE INDEX：创建索引（搜索键）\nDROP INDEX：删除索引\nDML（Data Manipulation Language，数据操纵语言）用来查询或者变更表中的记录。DML 包含以下几种指令。\nINSERT INTO：向数据库中插入新数据\nUPDATE：更新数据库中的数据\nSELECT: 从数据库中提取数据\nDELETE：从数据库中删除数据\nDCL（Data Control Language，数据控制语言） 用来确认或者取消对数据库中的数据进行的变更。除此之外，还可以对 RDBMS 的用户是否有权限操作数据库中的对象（数据库表等）进行设定。DCL 包含以下几种指令。\nCOMMIT：确认对数据库中的数据进行的变更\nROLLBACK：取消对数据库中的数据进行的变更\nGRANT：赋予用户操作权限\nREVOKE：取消用户的操作权限","数据类型#数据类型":"在 MySQL 中，有三种主要的类型：文本、数字和日期/时间类型。Text 类型：\n数据类型\t描述\tCHAR(size)\t保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符。\tVARCHAR(size)\t保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。注释：如果值的长度大于 255，则被转换为 TEXT 类型。\tTINYTEXT\t存放最大长度为 255 个字符的字符串。\tTEXT\t存放最大长度为 65,535 个字符的字符串。\tBLOB\t用于 BLOBs (Binary Large OBjects)。存放最多 65,535 字节的数据。\tMEDIUMTEXT\t存放最大长度为 16,777,215 个字符的字符串。\tMEDIUMBLOB\t用于 BLOBs (Binary Large OBjects)。存放最多 16,777,215 字节的数据。\tLONGTEXT\t存放最大长度为 4,294,967,295 个字符的字符串。\tLONGBLOB\t用于 BLOBs (Binary Large OBjects)。存放最多 4,294,967,295 字节的数据。\tENUM(x,y,z,etc.)\t允许你输入可能值的列表。可以在 ENUM 列表中列出最大 65535 个值。如果列表中不存在插入的值，则插入空值。注释：这些值是按照你输入的顺序存储的。可以按照此格式输入可能的值：ENUM('X','Y','Z')\tSET\t与 ENUM 类似，SET 最多只能包含 64 个列表项，不过 SET 可存储一个以上的值。\t\nNumber 类型：\n数据类型\t描述\tTINYINT(size)\t-128 到 127 常规。0 到 255 无符号*。在括号中规定最大位数。\tSMALLINT(size)\t-32768 到 32767 常规。0 到 65535 无符号*。在括号中规定最大位数。\tMEDIUMINT(size)\t-8388608 到 8388607 普通。0 to 16777215 无符号*。在括号中规定最大位数。\tINT(size)\t-2147483648 到 2147483647 常规。0 到 4294967295 无符号*。在括号中规定最大位数。\tBIGINT(size)\t-9223372036854775808 到 9223372036854775807 常规。0 到 18446744073709551615 无符号*。在括号中规定最大位数。\tFLOAT(size,d)\t带有浮动小数点的小数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。\tDOUBLE(size,d)\t带有浮动小数点的大数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。\tDECIMAL(size,d)\t作为字符串存储的 DOUBLE 类型，允许固定的小数点。\t\n这些整数类型拥有额外的选项 UNSIGNED。通常，整数可以是负数或正数。如果添加 UNSIGNED 属性，那么范围将从 0 开始，而不是某个负数。\nDate 类型：\n数据类型\t描述\tDATE()\t日期。格式：YYYY-MM-DD 注释：支持的范围是从 '1000-01-01' 到 '9999-12-31'\tDATETIME()\t*日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS 注释：支持的范围是从 '1000-01-01 00:00:00' 到 '9999-12-31 23:59:59'\tTIMESTAMP()\t*时间戳。TIMESTAMP 值使用 Unix 纪元('1970-01-01 00:00:00' UTC) 至今的描述来存储。格式：YYYY-MM-DD HH:MM:SS 注释：支持的范围是从 '1970-01-01 00:00:01' UTC 到 '2038-01-09 03:14:07' UTC\tTIME()\t时间。格式：HH:MM:SS 注释：支持的范围是从 '-838:59:59' 到 '838:59:59'\tYEAR()\t2 位或 4 位格式的年。注释：4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。\t\n即便 DATETIME 和 TIMESTAMP 返回相同的格式，它们的工作方式很不同。在 INSERT 或 UPDATE 查询中，TIMESTAMP 自动把自身设置为当前的日期和时间。TIMESTAMP 也接受不同的格式，比如 YYYYMMDDHHMMSS、YYMMDDHHMMSS、YYYYMMDD 或 YYMMDD。","示例#示例":"-- 创建数据库\nCREATE DATABASE shop;\n-- 创建表\nCREATE TABLE Product(\n    product_id CHAR(4) NOT NULL,\n    product_name VARCHAR(100) NOT NULL,\n    product_type VARCHAR(32) NOT NULL,\n    sale_price INTEGER,\n    purchase_price INTEGER,\n    regist_date DATE,\n    PRIMARY KEY (product_id));\n    -- 第 12 行也可以合并到第 6 行：\n    -- product_id CHAR(4) PRIMARY KEY NOT NULL\n该语法清楚地描述了我们要创建一个包含 列名 1、列名 2、 ……的名称为 <表名> 的表，非常容易理解。每一列的数据类型（后述）是必须要指定的，还要为需要的列设置约束（后述）。约束可以在定义列的时候进行设置，也可以在语句的末尾进行设置。命名规则上：我们只能使用半角英文字母、数字、下划线（_）作为数据库、表和列的名称。例如，不能将 product_id 写成 product-id，因为标准 SQL 并不允许使用连字符作为列名等名称。$、#、? 这样的符号同样不能作为名称使用。\n-- 修改（添加）列\n-- DB2 PostgreSQL MySQL\nALTER TABLE Product ADD COLUMN product_name_pinyin VARCHAR(100);\n-- Oracle\nALTER TABLE Product ADD (product_name_pinyin VARCHAR2(100));\n-- SQL Server\nALTER TABLE Product ADD product_name_pinyin VARCHAR(100);\n-- 删除列\n-- SQL Server DB2 PostgreSQL MySQL\nALTER TABLE Product DROP COLUMN product_name_pinyin;\n-- Oracle\nALTER TABLE Product DROP (product_name_pinyin);\n-- 删除表\nDROP TABLE Product;\n插入数据：\n-- SQL Server PostgreSQL\nBEGIN TRANSACTION;\n-- MySQL\nSTART TRANSACTION;\nINSERT INTO Product VALUES('0001', 'T恤衫', '衣服', 1000, 500, '2009-09-20');\nINSERT INTO Product VALUES('0002', '打孔器', '办公用品', 500, 320, '2009-09-11');\nINSERT INTO Product VALUES('0003', '运动T恤', '衣服', 4000, 2800, NULL);\nINSERT INTO Product VALUES('0004', '菜刀', '厨房用具', 3000, 2800, '2009-09-20');\nINSERT INTO Product VALUES('0005', '高压锅', '厨房用具', 6800, 5000, '2009-01-15');\nINSERT INTO Product VALUES('0006', '叉子', '厨房用具', 500, NULL, '2009-09-20');\nINSERT INTO Product VALUES('0007', '擦菜板', '厨房用具', 880, 790, '2008-04-28');\nINSERT INTO Product VALUES('0008', '圆珠笔', '办公用品', 100, NULL, '2009-11-11');\nCOMMIT;","定义数据表的约束#定义数据表的约束":"数据的完整性是指保护数据库中数据的正确性、有效性和相容性，防止错误的数据进入数据库造成无效操作。SQL Server 提供的数据完整性机制主要包括：约束（Constraint）、默认（Default）、规则（Rule）、触发器（Trigger）、存储过程（Stored Procedure）等。本节只介绍约束。约束是 SQL Server 自动强制数据库完整性的方式，约束定义了列中允许的取值。在 SQL Server 中，对于数据表的约束分为列约束和表约束。其中，列约束是对某一个特定列的约束，包含在列定义中，直接跟在该列的其他定义之后，用空格分隔，不必指定列名；表约束与列定义相互独立，不包括在列定义中，通常用于对多个列一起进行约束，与列定义用“，”分隔，定义表约束时必须指出要约束的列的名称。完整性约束的基本语法格式为：CONSTRAINT <约束名> (约束类型)约束名：约束不指定名称时，系统会给定一个名称。约束类型：在定义完整性约束时必须指定完整性约束的类型。在 SQL Server 中可以定义 5 种类 型的完整性约束，下面分别加以介绍。\nNULL / NOT NULL 约束NULL 值不是 0，也不是空白，更不是填入字符串“NULL”，而是表示“不知道”“不确定”或“没有数据”的意思。当某一字段的值一定要输入值才有意义的时候，则可以设置为 NOT NULL。例如，主键列就不允许出现空值，否则就失去了唯一标识一条记录的作用。如：\nCREATE TABLE S(\n\tSNo VARCHAR(6) CONSTRAINT S_CONS NOT NULL\n\tSN NVARCHAR(10),\n    Sex NCHAR(1),\n    Age INT,\n    Dept NVARCHAR(20));\n其中，S_CONS 为指定的约束名称（也可以不加约束名称，加是为了更好的维护约束规则）。有了 NOT NULL 约束，在 S 表中录入数据，当 SNo 为空时，系统给出错误信息。无 NOT NULL 约束时，系统缺省为 NULL。\nUNIQUE 约束（唯一约束）UNIQUE 约束用于指明基本表在某一列或多个列的组合上的取值必须唯一。定义了 UNIQUE 约束的那些列称为唯一键，系统自动为唯一键建立唯一索引，从而保证了唯一键的唯一性。唯一键允许为空，但系统为保证其唯一性，最多只可以出现一个 NULL 值。在建立 UNIQUE 约束时，需要考虑以下几个因素：\n使用 UNIQUE 约束的字段允许为 NULL 值。\n一个表中可以允许有多个 UNIQUE 约束。\n可以把 UNIQUE 约束定义在多个字段上。\nUNIQUE 约束用于强制在指定字段上创建一个 UNIQUE 索引，缺省为非聚集索引。\nUNIQUE 既可用于列约束，也可用于表约束。\nPRIMARY KEY 约束（主键约束）PRIMARY KEY 约束用于定义基本表的主键，起唯一标识作用，其值不能为 NULL，也不能重复，以此来保证实体的完整性。PRIMARY KEY 与 UNIQUE 约束类似，通过建立唯一索引来保证基本表在主键列取值的唯一性，但它们之间存在着很大的区别。\n在一个基本表中只能定义一个 PRIMARY KEY 约束，但可定义多个 UNIQUE 约束。\n对于指定为 PRIMARY KEY 的一个列或多个列的组合，其中任何一个列都不能出现 NULL 值，而对于 UNIQUE 所约束的唯一键，则允许为 NULL。\n不能为同一个列或一组列，既定义 UNIQUE 约束，又定义 PRIMARY KEY 约束。\nFOREIGN KEY 约束（外键约束）FOREIGN KEY 约束指定某一列或几列作为外部键。其中，包含外部键的表称为从表，包含外部键所引用的主键或唯一键的表称为主表。系统保证从表在外部键上的取值是主表中某一个主键值或唯一键值，或者取空值，以此保证两表间的参照完整性。FOREIGN KEY 既可用于列约束，也可用于表约束，其语法格式为：\nCONSTRAINT (约束名) FOREIGN KEY REFERENCES <主表名>(<列名>[{,<列名>}])\n如：建立一个 SC 表，定义 SNo、CNo 为 SC 的外部键。\nCREATE TABLE SC(\n\tSNo VARCHAR(6) NOT NULL CONSTRAINT S_Fore\n    \tFOREIGN KEY REFERENCES S(SNo),\n\tCNo VARCHAR(6) NOT NULL CONSTRAINT C_Fore\n    \tFOREIGN KEY REFERENCES C(CNo),\n\tScore NUMERIC(4,1),\n\tCONSTRAINT S_C_Prim PRIMARY KEY(SNo, CNo));\nCHECK 约束CHECK 约束用来检查字段值所允许的范围，如一个字段只能输入整数，而且限定在 0 ～ 100 的整数，以此来保证域的完整性。在建立 CHECK 约束时，需要考虑以下几个因素：\n一个表中可以定义多个 CHECK 约束。\n每个字段只能定义一个 CHECK 约束。\n在多个字段上定义的 CHECK 约束必须为表约束。\n当执行 INSERT、UPDATE 语句时，CHECK 约束将验证数据。\nCHECK 既可用于列约束，也可用于表约束。如：\n-- 建立一个 SC 表，定义 Score 的取值范围为 0～100 之间。\nCREATE TABLE SC(\n    SNo VARCHAR(6),\n    CNo VARCHAR(6),\n    Score NUMERIC(4,1) CONSTRAINT Score_Chk CHECK(Score>=0 AND Score <=100))\n-- 建立包含完整性定义的学生表 S。\nCREATE TABLE S(\n    SNo VARCHAR(6) CONSTRAINT S_Prim PRIMARY KEY,\n    SN NVARCHAR(10) CONSTRAINT SN_Cons NOT NULL,\n    Sex NCHAR(1) CONSTRAINT Sex_Cons NOT NULL DEFAULT '男',\n    Age INT CONSTRAINT Age_Cons NOT NULL\n    \tCONSTRAINT Age_Chk CHECK (Age BETWEEN 15 AND 50),\n    Dept NVARCHAR(20) CONSTRAINT Dept_Cons NOT NULL));","修改表#修改表":"ADD 方式如：在 S 表中增加一个班号列和住址列。\nALTER TABLE S ADD\n    Class_No VARCHAR(6),\n    Address NVARCHAR(20);\nALTER 方式如：把 S 表中的 SN 列加宽到 12 个字符。\nALTER TABLE S ALTER\n\tCOLUMN SN NVARCHAR(12)\n注意：使用此方式有如下一些限制：\n不能改变列名。\n不能将含有空值的列的定义修改为 NOT NULL 约束。\n若列中已有数据，则不能减少该列的宽度，也不能改变其数据类型。\n只能修改 NULL/NOT NULL 约束，其他类型的约束在修改之前必须先将约束删除，然后再重新添加修改过的约束定义。\nDROP 方式如：删除 S 表中的主键。\nALTER TABLE S DROP\n\tCONSTRAINT S_Prim\n参考：看完这篇文章保证你学会 sql 的增删改 - 知乎 (zhihu.com)，有删改。","约束条件都有什么用#约束条件都有什么用":"约束是在表上强制执行的数据检验规则；\n用来保证创建的表的数据完整和正确；\n当表中数据有相互依赖性时，可以保护相关的数据不被删除。\n主键（primary key）：一个表格只能有一个主键，但可以是数据表中一列或多列的组合，可以是单字段主键，也可以是多字段联合主键。\n主键约束要求主键列的数据必须是唯一的，并且不允许为空。\n使用主键，能够惟一地标识表中的一条记录，并且可以结合外键来定义不同数据表之间的关系，还可以加快数据库查询的速度。\n非空约束（not null）：指的是字段的值不能为空：多个空值不代表重复，代表未知。唯一性约束（unique）：要求该列的值必须是唯一的。\n一个表中可以有多个字段声明为唯一的；\n唯一约束确保数据表的一列或几列不出现重复值。\n外键（foreign key）：用来在两个表的数据之间建立链接。\n一个数据表可以有一个或多个外键；\n外键对应的是参照完整性，其值可以是空值，若不为空值，则每一个外键值必须等于另一个表中主键的某个值；\n主表：主键所在的表；从表：外键所在的表。\n默认约束（Default）：指定某个字段的默认值，默认值的类型与字段类型一致。自增字段（auto_increment），在数据库应用中，希望主键列的值自动生成：\n和主键结合在一起用；\n只能是数值类型；\n将其设为自动增长列，列值由系统自动生成，每次加 1；\n只能有一个列设为自动增长列，且该字段必须是主键的一部分。\n可以删除的约束：非空、默认、自动增长无法删除的约束：键值约束包括主键约束、唯一约束、外键约束。","建#建":"-- 创建学生表\nCREATE TABLE stu(\ns_id VARCHAR(10) PRIMARY KEY,\ns_name VARCHAR(10) NOT NULL,\ns_age DATE NOT NULL,\ns_sex VARCHAR(10) DEFAULT \"未知\");\n-- 课程表\nCREATE TABLE co(\nc_id VARCHAR(10),\nc_name VARCHAR(10) NOT NULL,\nt_id VARCHAR(10) NOT NULL,\nPRIMARY KEY(c_id));\n-- 教师表\nCREATE TABLE te(\nt_id VARCHAR(10) PRIMARY KEY,\nt_name VARCHAR(10) NOT NULL);\n-- 成绩表\nCREATE TABLE sc(\ns_id VARCHAR(10) NOT NULL,\nc_id VARCHAR(10) NOT NULL,\nscore INT NOT NULL);","增#增":"-- 学生表添加数据\nINSERT into stu VALUES\n('01' , '赵雷' , '1989-01-01' , '男'),\n('02' , '钱电' , '1990-12-21' , '男'),\n('03' , '孙风' , '1990-05-20' , '男'),\n('04' , '李云' , '1990-08-06' , '男'),\n('05' , '周梅' , '1991-12-01' , '女'),\n('06' , '吴兰' , '1992-03-01' , '女'),\n('07' , '郑竹' , '1992-04-21' , '女'),\n('08' , '王菊' , '1990-01-20' , '女');\n-- 课程表添加数据\nINSERT into co VALUES\n('01' , '语文' , '02'),\n('02' , '数学' , '01'),\n('03' , '英语' , '03');\n-- 教师表添加数据\nINSERT into te VALUES\n('01' , '张三'),\n('02' , '李四'),\n('03' , '王五');\n-- 课程表添加数据\nINSERT into sc VALUES\n('01' , '01' , 80),\n('01' , '02' , 90),\n('01' , '03' , 99),\n('02' , '01' , 70),\n('02' , '02' , 60),\n('02' , '03' , 80),\n('03' , '01' , 80),\n('03' , '02' , 80),\n('03' , '03' , 80),\n('04' , '01' , 50),\n('04' , '02' , 30),\n('04' , '03' , 20),\n('05' , '01' , 76),\n('05' , '02' , 87),\n('06' , '01' , 31),\n('06' , '03' , 34),\n('07' , '02' , 89),\n('07' , '03' , 98);\n查看数据：\nDESC stu;\nDESC co;\nDESC te;\n查看表的内容：\nSELECT*FROM stu;\nSELECT*FROM co;\nSELECT*FROM te;\nSELECT*FROM sc;\n查看表的行数：\nselect count(*) from co;\nselect count(*) from sc;\nselect count(*) from stu;\nselect count(*) from te;","删#删":"删除表格（drop table）：\nDROP TABLE stu;\nDROP TABLE sc;\nDROP TABLE co;\nDROP TABLE te;\n删除字段内容：\nDELETE FROM stu;\nDELETE FROM co;\nDELETE FROM te;\nDELETE FROM sc;","改#改":"修改表名称：rename\nALTER TABLE stu rename student;\nSHOW TABLES;\n修改字段类型：modify\nALTER TABLE student MODIFY s_id VARCHAR(50);\nDESC student;\n修改字段名称：change\nALTER TABLE student CHANGE s_id stu_id VARCHAR(20);\nDESC student;\n增加字段：add\nALTER TABLE student add s_weight FLOAT FIRST;\nDESC student;\n更改字段顺序：modify 配合 after/before\nALTER TABLE student MODIFY s_weight FLOAT AFTER stu_id;\nDESC student;\n删除字段：drop\nALTER TABLE student DROP s_weight, MODIFY stu_id VARCHAR(100);\nDESC student;\n多个步骤是没有先后关系的。\n删除和增加键值约束：drop 和 add删除主键：DROP PRIMARY KEY\nALTER TABLE student DROP PRIMARY KEY;\nDESC student;\n增加主键：ADD PRIMARY KEY()\nALTER TABLE student ADD PRIMARY KEY(stu_id);\nDESC student;\n增加外键：sc ADD FOREIGN KEY()\nALTER TABLE sc ADD FOREIGN KEY(s_id) REFERENCES student(stu_id);\nDESC sc;\n怎么删除带外键的主键？\nALTER TABLE student DROP PRIMARY KEY;\nDESC student;\n查找外键名称\nSHOW CREATE TABLE sc;\n删除外键\nALTER TABLE sc DROP FOREIGN KEY sc_ibfk_1;\n再删除主键\nALTER TABLE student DROP PRIMARY KEY;\nDESC student;\n修改唯一约束：unique\nalter table student add unique(stu_id); -- 增加唯一约束\nalter table student add constraint abc unique(stu_id); -- constraint：给名称\nalter table student drop index abc; -- 删除唯一约束\n修改和删除数据：update 不加 table\nUPDATE student set s_name='朱一旦' where stu_id='01';\nSELECT * FROM student;","单关系表的数据查询#单关系（表）的数据查询":"数据查询是数据库中最常用的操作。SQL 提供 SELECT 语句，通过查询操作可得到所需的信息。关系（表）的 SELECT 语句的一般格式为：\nSELECT [ALL|DISTINCT][TOP N [PERCENT][WITH TIES]]\n\t<列名>(AS 别名 1) [{,<列名>(AS 别名 2)}]\n\tFROM <表名>(AS 表别名)\n\t[WHERE <检索条件>]\n\t[GROUP BY <列名 1> [HAVING <条件表达式>]]\n\t[ORDER BY <列名 2> [ASC|DESC]]\n查询的结果仍是一个表。SELECT 语句的执行过程是，根据 WHERE 子句的检索条件，从 FROM 子句指定的基本表中选取满足条件的元组，再按照 SELECT 子句中指定的列，投影得到结果表。如果有 GROUP 子句，则将查询结果按照与 <列名 1> 相同的值进行分组。如果 GROUP 子句后有 HAVING 短语，则只输出满足 HAVING 条件的元组。如果有 ORDER 子句，查询结果还要按照 ORDER 子句中 <列名 2> 的值进行排序。可以看出，WHERE 子句相当于关系代数中的选取操作，SELECT 子句则相当于投影操作，但 SQL 查询不必规定投影、选取连接的执行顺序，它比关系代数更简单、功能更强大。","无条件查询#无条件查询":"无条件查询是指只包含 SELECT ... FROM 的查询，这种查询最简单，相当于只对关系（表） 进行投影操作。如：\n-- 查询全体学生的姓名、学号和年龄。\nSELECT SNo, SN, Age\n\tFROM S\nSELECT * FROM S\n-- 用“*”表示 S 表的全部列名，而不必逐一列出。\n-- 使用关键字 DISTINCT 能消去重复行：\nSELECT DISTINCT SNo FROM SC","条件查询#条件查询":"当要在表中找出满足某些条件的行时，则需使用 WHERE 子句指定查询条件。WHERE 子句中，条件通常通过三部分来描述：\n列名。\n比较运算符。\n列名、常数。\n其中常用的比较运算符：\n运算符\t含义\t=、>、<、>=、<=、!=、<>\t比较大小\tAND、OR、NOT\t多重条件\tBETWEEN\tAND\tIN\t确定集合\tLIKE\t字符匹配\tIS\tNULL\t\n比较大小如：\n-- 查询选修课程号为 C1 的学生的学号和成绩。\nSELECT SNo,Score FROM SC\n\tWHERE CNo = 'C1'\n多重条件查询当 WHERE 子句需要指定一个以上的查询条件时，则需要使用逻辑运算符 AND、OR 和 NOT 将其连接成复合的逻辑表达式。其优先级由高到低为：NOT、AND、OR，用户可以使用括号改变优先级。如：\n-- 查询选修 C1 或 C2 且分数大于等于 85 分学生的学号、课程号和成绩。\nSELECT SNo, CNo, Score FROM SC\n\tWHERE (CNo = 'C1' OR CNo = 'C2') AND (Score >= 85)\n确定范围如：\n-- 查询选修 C1 或 C2 且分数大于等于 85 分学生的学号、课程号和成绩。\nSELECT TNo, TN, Prof FROM T\n\tWHERE Sal BETWEEN 1000 AND 1500\n-- 等价于：\nSELECT TNo, TN, Prof FROM T\n\tWHERE Sal>=1000 AND Sal<=1500\nSELECT TNo, TN, Prof FROM T\n\tWHERE Sal NOT BETWEEN 1000 AND 1500\n在 SQL Server 中，BETWEEN ... AND ... 的条件包含等号；在有些 DBMS 中，这样的条件不包含等号。\n确定集合利用“IN”操作可以查询属性值属于指定集合的元组。\n-- 查询选修 C1 或 C2 的学生的学号、课程号和成绩。\nSELECT SNo, CNo, Score FROM SC\n\tWHERE CNo IN('C1'，'C2')\n-- 此语句也可以使用逻辑运算符“OR”实现：\nSELECT SNo, CNo, Score FROM SC\n\tWHERE CNo = 'C1' OR CNo = 'C2'\n-- 查询没有选修 C1，也没有选修 C2 的学生的学号、课程号和成绩。\nSELECT SNo, CNo, Score FROM SC\n\tWHERE CNo NOT IN('C1'，'C2')\n-- 等价于：\nSELECT SNo, CNo, Score FROM SC\n\tWHERE (CNo <> 'C1') AND (CNo <> 'C2')\n部分匹配查询以上各例均属于完全匹配查询，当不知道完全精确的值时，用户还可以使用 LIKE 或 NOT LIKE 进行部分匹配查询（也称模糊查询）。LIKE 定义的一般格式为：<属性名> LIKE <字符串常量>其中，属性名必须为字符型，字符串常量中的字符可以包含通配符，利用这些通配符，可以进行模糊查询。字符串中的通配符及其功能：\n通配符\t功能\t实例\t含义\t%\t代表 0 个或多个字符\tab%\t'ab'后可接任意字符串\t_（下划线）\t代表一个字符\ta_b\t'a'与'b'之间可有一个字符\t[ ]\t表示在某一范围的字符\t[0-9]\t0~9 之间的字符\t[^ ]\t表示不在某一范围的字符\t[^0-9]\t不在 0~9 之间的字符\t\n如：\n-- 查询所有姓张的教师的教师号和姓名。\nSELECT TNo, TN FROM T\n   WHERE TN LIKE '张%'\n-- 查询姓名中第二个汉字是“力”的教师号和姓名。\nSELECT TNo, TN FROM T\n   WHERE TN LIKE'_力%'\n空值查询某个字段没有值称为具有空值（NULL）。通常没有为一个列输入值时，该列的值就是空值。空值不同于零和空格，它不占任何存储空间。如：\n-- 查询没有考试成绩的学生的学号和相应的课程号。\nSELECT SNo, CNo FROM SC\n\tWHERE Score IS NULL\n这里的空值条件为 Score IS NULL，不能写成 Score=NULL。","常用库函数及统计汇总查询#常用库函数及统计汇总查询":"SQL 提供了许多库函数，增强了基本检索能力。常用的库函数：\n函数名称\t功能\tAVG\t按列计算平均值\tSUM\t按列计算值的总和\tMAX\t求一列中的最大值\tMIN\t求一列中的最小值\tCOUNT\t按列值统计个数\t\n如：\n-- 求学号为 S1 的学生的总分和平均分。\nSELECT SUM(Score) AS TotalScore,\n\tAVG(Score) AS AvgScore\n\tFROM SC WHERE (SNo = 'S1')\n查询结果：\nTotalScore\tAvgScore\t175\t87.5\t\n上述查询语句中 AS 后面的 TotalScore 和 AvgScore 是别名，别名会显示在查询结果中，让使用者能清楚地知道查询内容所表示的含义。\n在使用库函数进行查询时，通常要给查询的每一项内容加别名，否则查询结果中就不显示列名。\n如：\n-- 求选修 C1 号课程的最高分、最低分及之间相差的分数。\nSELECT MAX(Score) AS MaxScore,\n\tMIN(Score) AS MinScore,\n\tMAX(Score)－MIN(Score) AS Diff\n\tFROM SC WHERE (CNo = 'C1')\n-- 求计算机系学生的总数。\nSELECT COUNT（SNo）FROM S\n\tWHERE Dept= '计算机'\n-- 求学校中共有多少个系。\nSELECT COUNT(DISTINCT Dept) AS DeptNum FROM S\n-- 利用特殊函数 COUNT(*)求计算机系学生的总数。\nSELECT COUNT(*) FROM S WHERE Dept='计算机'\n加入关键字 DISTINCT 后表示消去重复行，可计算字段“Dept”不同值的数目。COUNT 函数对空值不计算，但对 0 进行计算。COUNT(*) 用来统计元组的个数，不消除重复行，不允许使用 DISTINCT 关键字。","分组查询#分组查询":"分组查询 GROUP BY 子句可以将查询结果按属性列或属性列组合在行的方向上进行分组，每组在属性列或属性列组合上具有相同的值。如：\n-- 查询每个教师的教师号及其任课的门数。\nSELECT TNo, COUNT(*) AS C_Num\n\tFROM TC GROUP BY TNo\nGROUP BY 子句按 TNo 的值分组，所有具有相同 TNo 的元组为一组，对每一组使用函数 COUNT 进行计算，统计出各位教师任课的门数。查询结果如下：\nTNo\tC_Num\tT1\t2\tT2\t2\tT3\t2\tT4\t2\tT5\t2\t\n若在分组后还要按照一定的条件进行筛选，则需使用 HAVING 子句。如：\n-- 查询选修两门以上（含两门）课程的学生的学号和选课门数。\nSELECT SNo, COUNT(*) AS SC_Num -- 新列 SNo、SC_Num\n\tFROM SC\n\tGROUP BY SNo -- 按学号分组\n\tHAVING (COUNT(*) >= 2) -- 条件：计数大于等于2\n查询结果如下：\nSNo\tSC_Num\tS1\t2\tS2\t4\tS3\t3\tS4\t3\t\nGROUP BY 子句按 SNo 的值分组，所有具有相同 SNo 的元组为一组，对每一组使用函数 COUNT 进行计算，统计出每个学生选课的门数。HAVING 子句去掉不满足 COUNT(*)>=2 的组。当在一个 SQL 查询中同时使用 WHERE 子句，GROUP BY 子句和 HAVING 子句时，其顺序是 WHERE、GROUP BY、HAVING。WHERE 与 HAVING 子句的根本区别在于作用对象不同。WHERE 子句作用于基本表或视图，从中选择满足条件的元组；HAVING 子句作用于组，选择满足条件的组， 必须用在 GROUP BY 子句之后，但 GROUP BY 子句可没有 HAVING 子句。","查询结果的排序#查询结果的排序":"当需要对查询结果排序时，应该使用 ORDER BY 子句，ORDER BY 子句必须出现在其他子句之后。排序方式可以指定：DESC 为降序，ASC 为升序，缺省时为升序。如：\n-- 查询选修 C1 的学生学号和成绩，并按成绩降序排列。\nSELECT SNo, Score FROM SC WHERE (CNo = 'C1')\n\tORDER BY Score DESC","多关系表的连接查询#多关系（表）的连接查询":"数据库中的各个表中存放着不同的数据，用户往往需要用多个表中的数据来组合、提炼出所需要的信息。如果一个查询需要对多个表进行操作，就称为连接查询。连接查询的结果集或结果表称为表之间的连接。连接查询实际上是通过各个表之间共同列的关联性来查询数据的，数据表之间的联系是通过表的字段值来体现的，这种字段称为连接字段。连接操作的目的就是通过加在连接字段上的条件将多个表连接起来，以便从多个表中查询数据。当查询同时涉及两个及两个以上的表时，称为连接查询。多关系（表）的连接查询结构表的连接方法有以下两种：\n表之间满足一定条件的行进行连接时，FROM 子句指明进行连接的表名，WHERE 子句指明 连接的列名及其连接条件：\nSELECT [ALL|DISTINCT] [TOP N [PERCENT][WITH TIES]]\n\t〈列名〉[AS 别名 1] (，列名2 [AS 别名 2])\n\tFROM〈表名 1〉[AS 表 1 别名] (，〈表名 2〉[AS 表 2 别名,...])\n\t[WHERE〈检索条件〉]\n\t[GROUP BY <列名 1> [HAVING <条件表达式>]]\n\t[ORDER BY <列名 2> [ASC|DESC]]\n利用关键字 JOIN 进行连接。\n具体的连接方法分为以下几种：\nINNER JOIN（内连接）显示符合条件的记录，此为默认值。\nLEFT（OUTER）JOIN 称为左（外）连接，用于显示符合条件的数据行以及左边表中不符合条件的数据行。此时右边数据行会以 NULL 来显示。\nRIGHT（OUTER）JOIN 称为右（外）连接，用于显示符合条件的数据行以及右边表中不符合条件的数据行。此时左边数据行会以 NULL 来显示。\nFULL（OUTER）JOIN 显示符合条件的数据行以及左边表和右边表中不符合条件的数据行。此时缺乏数据的数据行会以 NULL 来显示。\nCROSS JOIN 将一个表的每一个记录和另一表的每个记录匹配成新的数据行。\n当将 JOIN 关键词放于 FROM 子句中时，应有关键词 ON 与之对应，以表明连接的条件。\nSELECT [ALL|DISTINCT][TOP N [PERCENT][WITH TIES]]\n\t列名 1 [AS 别名 1] (, 列名 2 [ AS 别名 2]...)\n\t[INTO 新表名]\n\tFROM 表名 1 [[AS] 表 1 别名]\n\t[INNER|RIGHT|FULL|OUTER|CROSS] JOIN 表名 2 [[AS] 表 2 别名]\n\tON 条件\n下面介绍几种表的连接操作。\nSQL 多表查询：SQL JOIN 连接查询各种用法总结 - 知乎 (zhihu.com)","写在前面#写在前面":"在实际应用中，大多的查询都是需要多表连接查询的，但很多初学 SQL 的小伙伴总对各种 JOIN 有些迷糊。回想一下，初期很长一段时间，我常用的似乎也就是等值连接 WHERE 后面加等号，对各种 JOIN 也是不求甚解，今天索性就来个 JOIN 的小总结。首先，设定两张表，作为下面例子的操作对象。表 1 学生信息表：表 2 专业班级表：再来个 SQL JOIN 连接查询各种用法的大合影，先预热一下。","no1-inner-join内连接#No.1 【INNER JOIN】内连接":"这是最常用的，获取两个表中指定字段满足匹配关系的记录。内连接通常有两种情况：等值连接：查找两个表中连接字段相等的记录。\n-- 查询每个学生的学号、姓名、籍贯、年龄、专业、班级\n-- 涉及到 student 和 major 两张表，用共有字段“学号”为连接字段\n-- 写法1：使用 INNER JOIN\nSELECT A.学号, A.姓名, A.籍贯, A.年龄, B.专业, B.班级\n\tFROM student A\n\tINNER JOIN major B\n\tON  A.学号=B.学号\n-- 写法2：省去了 INNER，直接写 JOIN，与 INNER JOIN 没有区别\nSELECT A.学号, A.姓名, A.籍贯, A.年龄, B.专业, B.班级\n    FROM student A\n    JOIN major B\n    ON A.学号=B.学号\n-- 写法3：使用 WHERE，已经逐渐被淘汰\nSELECT A.学号, A.姓名, A.籍贯, A.年龄, B.专业, B.班级\n    FROM student A, major B\n    WHERE A.学号 = B.学号\n-- 上面三种写法的结果都是一样的，推荐使用写法2\n自身连接：就是和自己进行连接查询，给一张表取两个不同的别名，然后附上连接条件。\n-- 要在学生表里查询与 HH 同龄且籍贯也相同的学生信息\nSELECT B.学号, B.姓名, B.性别, B.籍贯, B.年龄\n    FROM student A\n    JOIN student B\n    ON A.年龄=B.年龄 AND A.籍贯=B.籍贯 AND A.姓名='HH'","no2-left-join左连接#No.2 【LEFT JOIN】左连接":"获取左表中的所有记录，即使在右表没有对应匹配的记录。\n-- 左连接：显示左表student所有记录，如右表中没有与之\n-- 匹配的项则以NULL值代替。\nSELECT A.学号, A.姓名, A.籍贯, A.年龄, B.专业, B.班级\n    FROM student A LEFT JOIN major B\n    ON  A.学号 = B.学号","no3-right-join右连接#No.3 【RIGHT JOIN】右连接":"用于获取右表中的所有记录，即使左表没有对应匹配的记录。\n-- 右连接：显示右表 major 所有记录，如左表中没有与之\n-- 匹配的项则以NULL值代替。\nSELECT A.学号, A.姓名, A.籍贯, A.年龄, B.专业, B.班级\n    FROM student A RIGHT JOIN major B\n    ON A.学号=B.学号","no4-full-join-完全连接#No.4 【FULL JOIN】 完全连接":"返回两个表中的所有行。\n-- 完全连接：显示两张表的并集，如果其中一张表的记录\n-- 在另一张表中没有匹配的行，则对应的数据项填充NULL\nSELECT A.学号, A.姓名, A.籍贯, A.年龄, B.专业, B.班级\n    FROM student A FULL JOIN major B\n    ON  A.学号=B.学号","no5-cross-join交叉连接#No.5 【CROSS JOIN】交叉连接":"结果是笛卡尔积，就是第一个表的行数乘以第二个表的行数。\n-- 交叉连接：一张表中的数据依次取出分别与另一张表中的\n-- 每条数据挨个组合，最后记录数量为两张表记录数的乘积\nSELECT * FROM student CROSS JOIN major\n-- 本例student和major都为7条记录，所以结果为7*7=49条记录","no6-延伸left-excluding-join左表唯一#No.6 延伸【Left Excluding JOIN】左表唯一":"返回左表有但右表没有关联数据的记录。\n-- 左表唯一：将右表B以及两张表交集的部分过滤掉，\n-- 得到的记录是左表中唯一存在的。\nSELECT A.学号, A.姓名, A.籍贯, A.年龄, B.专业, B.班级\n    FROM student A LEFT JOIN major B\n    ON A.学号 = B.学号\n    WHERE B.学号 IS NULL","no7-延伸right-excluding-join右表唯一#No.7 延伸【Right Excluding JOIN】右表唯一":"返回右表有但左表没有关联数据的记录。\n-- 右表唯一：将左表A以及两张表交集的部分过滤掉，\n-- 得到的记录是右表中唯一存在的。\nSELECT A.学号, A.姓名, A.籍贯, A.年龄, B.专业, B.班级\n    FROM student A RIGHT JOIN major B\n    ON A.学号=B.学号\n    WHERE A.学号 IS NULL","no8-延伸outer-excluding-join非交集连接#No.8 延伸【Outer Excluding JOIN】非交集连接":"返回左表和右表里没有相互关联的记录。\n-- 非交集连接：查找两张表中没有关联的记录项。\nSELECT A.学号, A.姓名, A.籍贯, A.年龄, B.专业, B.班级\n    FROM student A FULL JOIN major B\n    ON A.学号=B.学号\n    WHERE A.学号 IS NULL OR B.学号 IS NULL","最后#最后":"谈及 SQL 里的各种 JOIN 之间的区别时，被广为引用的是 CodeProject 上 C.L. Moffatt 的文章, 本文也有所参考，感兴趣的小伙伴可以去看一下。https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins","子查询#子查询":"在 WHERE 子句中包含一个形如 SELECT-FROM-WHERE 的查询块，此查询块称为子查询或嵌套查询，包含子查询的语句称为父查询或外部查询。嵌套查询可以将一系列简单查询构成复杂查询，增强查询能力。子查询的嵌套层次最多可达到 255 层，以层层嵌套的方式构造查询，充分体现了 SQL“结构化”的特点。嵌套查询在执行时由里向外处理，每个子查询是在上一级外部查询处理之前完成的，父查询要用到子查询的结果。","普通子查询#普通子查询":"普通子查询的执行顺序是：首先执行子查询，然后把子查询的结果作为父查询的查询条件的值。普通子查询只执行一次，而父查询所涉及的所有记录行都与其查询结果进行比较以确定查询结果集合。当子查询的返回值只有一个时，可以使用比较运算符（=、 >、 <、 >=、 <=、 !=）将父查询和子查询连接起来。如：查询与“刘伟”老师职称相同的教师号、姓名。\nSELECT TNo,TN FROM T\n\tWHERE Prof= (SELECT Prof FROM T WHERE TN='刘伟')\n-- 查询结果：\n-- TNo TN\n-- T2 王平\n-- T3 刘伟\n如果子查询的返回值不止一个，而是一个集合时，则不能直接使用比较运算符，可以在比较运算符和子查询之间插入 ANY 或 ALL。其具体含义详见以下各例。（1）使用 ANY。\n-- 查询讲授课程号为 C5 的教师姓名。\nSELECT TN FROM T\n\tWHERE (TNo = ANY(SELECT TNo FROM TC WHERE CNo = 'C5') )\n先执行子查询，找到讲授课程号为 C5 的教师号，教师号为一组值构成的集合(T2,T3,T5)；再执行父查询。其中 ANY 的含义为任意一个，查询教师号为 T2、T3、T5 的教师的姓名。查询结果如下：\nTN\t王平\t刘伟\t张兰\t\n该例也可以使用前面所讲的连接操作来实现：\nSELECT T.TN FROM T,TC\n\tWHERE T.TNo = TC.TNo AND TC.CNo= 'C5'\n可见，对于同一查询，可使用子查询和连接查询两种方法来解决，读者可根据习惯任意选用。又如：查询其他系中比计算机系某一教师工资高的教师的姓名和工资。\nSELECT TN, Sal FROM T\n\tWHERE (Sal > ANY(SELECT Sal FROM T WHERE Dept = ' 计算机'))\n\tAND (Dept <> '计算机') -- <> 代表不等于\n先执行子查询，找到计算机系中所有教师的工资集合（1500，900）；再执行父查询，查询所有不是计算机系且工资高于 900 元的教师姓名和工资。查询结果如下：\nTN\tSal\t张雪\t1600\t张兰\t1300\t\n此查询也可以写成：\nSELECT TN, Sal FROM T\n\tWHERE Sal > (SELECT MIN(Sal) FROM T WHERE Dept = '计算机')\n\tAND Dept <> '计算机'\n先执行子查询，利用库函数 MIN 找到计算机系中所有教师的最低工资 900 元；再执行父查询，查询所有不是计算机系且工资高于 900 元的教师。（2）使用 IN。可以使用 IN 代替“=ANY”。\n-- 查询讲授课程号为 C5 的教师姓名（使用 IN）。\nSELECT TN FROM T\n\tWHERE (TNo IN (SELECT TNo FROM TC WHERE CNo = 'C5'))\n（3）使用 ALL。ALL 的含义为全部。如：查询其他系中比计算机系所有教师工资都高的教师的姓名和工资。\nSELECT TN, Sal FROM T\n\tWHERE (Sal > ALL(SELECT Sal FROM T WHERE Dept='计算机') )\n\tAND (Dept <> '计算机')\n子查询找到计算机系中所有教师的工资集合(1500，900)，父查询找到所有不是计算机系且工资高于 1500 的教师姓名和工资。此查询也可以写成：\nSELECT TN, Sal FROM T\n\tWHERE (Sal > (SELECT MAX(Sal) FROM T WHERE Dept = '计算机'))\n\tAND (Dept <> '计算机')","相关子查询#相关子查询":"有时子查询的查询条件需要引用父查询表中的属性值，我们把这类查询称为相关子查询。相关子查询的执行顺序是：首先选取父查询表中的第一行记录，内部的子查询利用此行中相关的属性值进行查询，然后父查询根据子查询返回的结果判断此行是否满足查询条件。如果满足条件，则把该行放入父查询的查询结果集合中。重复执行这一过程，直到处理完父查询表中的每一行数据。如：查询不讲授课程号为 C5 的教师姓名。\nSELECT DISTINCT TN FROM T\n\tWHERE ('C5' <> ALL(SELECT CNo FROM TC WHERE TNo = T.TNo))\n-- <> ALL 的含义为不等于子查询结果中的任何一个值。也可使用 NOT IN 代替。\n此外，使用 EXISTS 也可以进行相关子查询。EXISTS 是表示存在的量词，带有 EXISTS 的子查询不返回任何实际数据，它只得到逻辑值“真”或“假”。当子查询的查询结果集合为非空时，外层的 WHERE 子句返回真值，否则返回假值。NOT EXISTS 与此相反。\nSELECT TN FROM T\n\tWHERE EXISTS\n\t(SELECT * FROM TC WHERE TNo = T.TNo AND CNo = 'C5')\n当子查询 TC 表存在一行记录满足其 WHERE 子句中的条件时，父查询便得到一个 TN 值，重复执行以上过程，直到得出最后结果。\n参考：MySQL 子查询--再难一看就懂 - 知乎 (zhihu.com)，有删改。子查询指一个查询语句嵌套在另一个查询语句内的查询。在 select 语句中先计算子查询，子查询结果作为外层另一个查询的过滤条件。\n标量子查询：子查询的值是固定的。\n关联子查询：内层查询与外层查询是有互动的。\n下面的例子的数据在 Chapter 3@建 部分有给出完整数据。此处不再给出如何创建数据，仅提供表格预览：\nstu (student) 表格：\nsc (score) 表格：\nco (course) 表格：\nte (teacher) 表格：","1-查询比学生编号为-02-的学生的最高成绩都高的成绩信息#1. 查询比学生编号为 02 的学生的最高成绩都高的成绩信息":"查询结果：成绩信息，sc 表所有字段信息\n查询条件：比学生编号为 02 的学生的最高成绩都高\n思路：先找到 02 的学生的最高成绩作为子查询，然后用“>”与子查询连接\nSELECT * FROM sc\n\tWHERE score > (SELECT MAX(score) FROM sc WHERE s_id='02');","2-查询平均成绩大于等于-85-的所有学生的学号姓名和平均成绩#2. 查询平均成绩大于等于 85 的所有学生的学号、姓名和平均成绩":"查询结果：所有学生的学号、姓名和平均成绩\n连接：所有学生、成绩所以是 stu 表作为左表，与 sc 表进行左连接\n查询条件：平均成绩大于等于 85\n思路：平均成绩大于等于 85 的学生，要先找到符合条件的学生学号，然后再通过匹配学号找到这些学生的信息。首先学生的平均成绩肯定是要按学号分组，分组后用 having 条件找到平均成绩>=85 的学生学号作为子查询。\nSELECT\n\tstu.s_id,\n\tstu.s_name,\n\tAVG( sc.score ) AS avgscore\nFROM\n\tstu\n\tJOIN sc ON stu.s_id = sc.s_id\nGROUP BY\n\tstu.s_id\nHAVING\n\tAVG( sc.score ) >= 85;","3-查询选修了全部课程的学生信息#3. 查询选修了全部课程的学生信息：":"查询结果：学生信息\n连接：学生、成绩及全部课程所以是 stu 表作为左表，与 sc 和 co 进行内连接\n查询条件：选修了全部课程\n思路：先想到全部课程数量是多少（通过 co 表计算课程总数量）；选修了全部课程，意思是每个学生所修不同课程的数量与全部课程的数量相同（因为出现“每个”所以要分组，针对每个学生的课程数量进行计算所以用 having 后加条件）\nSELECT\n\tstu.*\nFROM\n\tstu\n\tJOIN sc ON stu.s_id = sc.s_id\n\tJOIN co ON sc.c_id = co.c_id\nGROUP BY\n\tstu.s_id\nHAVING\n\tCOUNT(sc.c_id) = (SELECT COUNT(DISTINCT co.c_id) FROM co);","4-按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩#4. 按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩":"查询结果：所有学生、所有课程、所有成绩以及平均成绩\n连接：所有学生、成绩及全部课程所以是 stu 表作为左表，与 sc 进行左连接\n查询条件：所有课程的成绩以及平均成绩\n排序：按平均成绩从高到低，降序\n思路：因为要同时显示成绩和平均成绩，而平均是聚合函数平均成绩是通过学号分组得来的，行数是不同的；如果想同时显示的，子查询作为子表通过学号与需要显示的其他信息进行连接。注意：作为子表时一定要给别名。\nSELECT stu.s_name, co.c_name, sc.score, a.avgscore\nFROM stu\n\tLEFT JOIN sc\n\tON stu.s_id = sc.s_id\n\tLEFT JOIN (\n\t\tSELECT sc.s_id, AVG(sc.score) AS avgscore\n\t\tFROM sc\n\t\tGROUP BY sc.s_id\n\t) AS a\n\tON sc.s_id = a.s_id\n\tLEFT JOIN co\n\tON sc.c_id = co.c_id\nORDER BY\n\ta.avgscore DESC;","5-查询没学过张三老师授课的同学的信息#5. 查询没学过“张三”老师授课的同学的信息；":"查询结果：学生信息，主要是 stu 表信息\n连接：子查询时用到连接，学生、教师名字，所以是 stu 表作为左表，与 sc、co 和 te 进行内连接\n查询条件：没学过“张三”老师授课\n思路：先找到学过张三老师授课的学生学号作为子查询，通过 where s_id not in + 子查询进行筛选\nSELECT * FROM stu\nWHERE s_id NOT IN (\n\tSELECT stu.s_id FROM stu\n\t\tJOIN sc ON stu.s_id = sc.s_id\n\t\tJOIN co ON sc.c_id = co.c_id\n\t\tJOIN te ON co.t_id = te.t_id\n\tWHERE\n\t\tte.t_name = '张三'\n\tGROUP BY stu.s_id );","6-查询至少有一门课与学号为01的同学所学相同的同学的信息#6. 查询至少有一门课与学号为“01”的同学所学相同的同学的信息":"查询结果：学生信息，主要是 stu 表信息\n连接：学生、课程号，所以是 stu 表作为左表，与 sc 进行内连接\n查询条件：至少有一门课与学号为“01”的同学所学相同\n思路：先找到学号为“01”的同学所学课程，只要其他同学课程与 1 号同学所学任一课程相同就符合条件。\n方法一：\nSELECT stu.* FROM stu\n\tJOIN sc ON stu.s_id = sc.s_id\nWHERE\n\tc_id = ANY ( SELECT c_id FROM sc WHERE s_id = '01' )\nGROUP BY\n\tstu.s_id;\n方法二：通过课程号只要在 1 号同学所学课程里的学号进行筛选。\nSELECT *\nFROM stu\nWHERE\n\ts_id IN (\n\t\tSELECT s_id FROM sc\n\t\tWHERE c_id IN ( SELECT c_id FROM sc WHERE s_id = \"01\" )\n\t);","7-查询学过编号为01并且也学过编号为02的课程的同学的信息#7. 查询学过编号为“01”并且也学过编号为“02”的课程的同学的信息":"查询结果：学生信息，主要是 stu 表信息\n连接：学生、课程号，所以是 stu 表作为左表，与 sc 进行内连接\n查询条件：学过编号为“01”并且也学过编号为“02”的课程\n方法一：通过 having sum(c_id='01') 来实现\nSELECT stu.*\nFROM stu\n\tJOIN sc ON stu.s_id = sc.s_id\nGROUP BY stu.s_id\nHAVING SUM( c_id = '01' ) AND SUM( c_id = '02' );\n-- SUM() 输出包含条件的行数，没有就返回 0，也就是否定的意思。只有两者的 SUM() 都大于等于 1，才能允许被输出\n方法二：找到学过 01 课程和 02 课程的学号，通过 where+学号+子查询来筛选\nSELECT * FROM stu\nWHERE\n\ts_id IN ( SELECT s_id FROM sc WHERE c_id = '01' )\n\tAND s_id IN ( SELECT s_id FROM sc WHERE c_id = '02' );","8-查询01课程比02课程成绩高的学生的信息及课程分数#8. 查询“01”课程比“02”课程成绩高的学生的信息及课程分数":"查询结果：学生信息，主要是 stu 表信息及课程分数\n连接：学生、课程号，所以是 stu 表作为左表，与 sc 进行内连接\n查询条件：“01”课程比“02”课程成绩高的学生\n方法一：通过 having SUM((c_id='01')*score)>SUM((c_id='02')*score) 来实现，但前提是两个课程都存在通过此代码证实存在 SUM(c_id='01')>0 AND SUM(c_id='02')>0\nSELECT stu.*, sc.c_id, sc.score FROM stu\n\tJOIN sc ON stu.s_id = sc.s_id\nWHERE stu.s_id IN (\n\tSELECT stu.s_id FROM stu\n\t\tJOIN sc ON stu.s_id = sc.s_id\n\tGROUP BY stu.s_id\n\tHAVING\n\t\tSUM( c_id = '01' ) > 0 AND SUM( c_id = '02' ) > 0\n\t\tAND SUM(( c_id = '01' ) * score ) > SUM(( c_id = '02' ) * score )\n\t);\n方法二：找到 01 和 02 课程的成绩信息，分别作为子表与 stu 表通过学号和课程号='01'/'02' 进行连接，通过 where+子查询 sc.score>sc2.score 来筛选。最后将筛选出的学号作为子查询，找出学生信息及成绩。\nSELECT stu.*, sc.c_id, sc.score FROM stu\n\tJOIN sc ON stu.s_id = sc.s_id\nWHERE\n\tstu.s_id IN (\n\tSELECT stu.s_id FROM stu\n\t\tJOIN sc AS sc01 ON stu.s_id = sc01.s_id AND sc01.c_id = '01'\n\t\tJOIN sc AS sc02 ON stu.s_id = sc02.s_id AND sc02.c_id = '02'\n\tWHERE sc01.score > sc02.score\n\t);","9-查询学过编号为01但是没有学过编号为02的课程的同学的信息#9. 查询学过编号为“01”但是没有学过编号为“02”的课程的同学的信息":"与 7 题大同小异。方法一：\nSELECT stu.* FROM stu\nJOIN sc ON stu.s_id = sc.s_id\nGROUP BY stu.s_id\nHAVING SUM(c_id='01') > 0 AND SUM(c_id='02') = 0;\n方法二：\nSELECT * FROM stu\nWHERE s_id in (SELECT s_id FROM sc WHERE c_id='01')\n\tAND s_id not in (SELECT s_id FROM sc WHERE c_id='02');","10-查询有一门课程成绩在-70-分以上的姓名课程名称和分数#10. 查询有一门课程成绩在 70 分以上的姓名、课程名称和分数":"查询结果：姓名、课程名称和分数\n连接：学生姓名、课程名称、分数，所以是 stu 表作为左表，与 sc 和 co 表进行内连接\n查询条件：有一门课程成绩在 70 分以上的学生\n方法一：通过 HAVING SUM(score>70)>0 找到符合条件的学号，然后通过 s_id+in+(子查询实现)\nSELECT s_name, c_name, score FROM stu\n\tJOIN sc ON stu.s_id = sc.s_id\n\tJOIN co ON sc.c_id = co.c_id\nGROUP BY stu.s_id\nHAVING SUM( score > 70 ) > 0;\n方法二：只要最大成绩大于 70 分则存在大于 70 分的课程找到学号，再通过 s_id in (子查询) 实现。\nSELECT s_name, c_name, score\nFROM stu\n\tJOIN sc ON stu.s_id = sc.s_id\n\tJOIN co ON sc.c_id = co.c_id\nWHERE stu.s_id IN (\n\tSELECT s_id FROM sc\n\tGROUP BY s_id\n\tHAVING MAX( score )> 70 );","11-查询选修张三老师所授课程的学生中成绩最高的学生信息及其成绩#11. 查询选修“张三”老师所授课程的学生中，成绩最高的学生信息及其成绩":"查询结果：学生信息和成绩\n连接：学生姓名、课程名称、分数，所以是 stu 表作为左表，与 sc、co 及 te 表进行内连接\n查询条件：选修“张三”老师所授课程的学生中，成绩最高的学生\n思路：条件一选修张三老师的课程，where t_name='张三'；条件二成绩最高；通过 score=最高成绩子查询而且where t_name='张三'来实现。\nSELECT stu.*, sc.score FROM stu\n\tJOIN sc ON stu.s_id = sc.s_id\n\tJOIN co ON sc.c_id = co.c_id\n\tJOIN te ON co.t_id = te.t_id\nWHERE t_name = '张三' AND score = (\n\tSELECT MAX( score )\n\tFROM stu\n\t\tJOIN sc ON stu.s_id = sc.s_id\n\t\tJOIN co ON sc.c_id = co.c_id\n\t\tJOIN te ON co.t_id = te.t_id\n\tWHERE t_name = '张三'\n\t);","12-查询每门课程的成绩第-2-名到第-3-名的学生信息及该课程成绩#12. 查询每门课程的成绩第 2 名到第 3 名的学生信息及该课程成绩":"查询结果：学生信息和成绩\n连接：学生姓名、课程名称、分数，所以是 stu 表作为左表，与 sc 表进行内连接\n查询条件：每门课程的成绩第 2 名到第 3 名的学生\n方法一：窗口函数实现，row_number() over((PARTITION by c_id ORDER BY score DESC)计算出排名列，然后通过 where+in(2,3) 实现\nSELECT a.* FROM (\n\tSELECT stu.*, sc.c_id, sc.score,\n\t\tROW_NUMBER() over ( PARTITION BY c_id ORDER BY score DESC ) AS ranks\n\tFROM stu\n\t\tJOIN sc ON stu.s_id = sc.s_id\n\t) AS a\nWHERE\n\tranks IN ( 2, 3 );\nSQL 数据分析-窗口函数 ROW_NUMBER() - 知乎 (zhihu.com)SQL 中有一类函数叫聚合函数，比如 count、sum、avg、min数据按照规整聚集为一行，一般聚集前的数据行要大于聚集后的数据行。而有时候我们不仅想要聚集前的数据，又想要聚集后的数据，这时候便引入了窗口函数。涉及知识点有用于排序的窗口函数、用于用户分组查询的窗口函数、用于偏移分析的窗口函数。","row_number-函数#row_number 函数":"作用：分组聚合，先分组在进行排序。使用方法：row_number() over(partition by 列名1 order by 列名2 desc)表示根据 列名 1 分组，然后在分组内部根据 列名 2 排序，而此函数计算的值就表示每组内部排序后的顺序编号,可以用于去重复值。\n方法二：关联子查询：两个 sc 表通过 c_id 相同进行连接，然后再用 SUM(sc.score<score) 进行筛选\nSELECT stu.*, sc.c_id, sc.score FROM sc\n\tJOIN stu ON stu.s_id = sc.s_id\nWHERE (\n\tSELECT SUM( sc.score < sc1.score )\n\tFROM sc AS sc1 WHERE sc1.c_id = sc.c_id\n\t)\n\tIN ( 1, 2 );\n代码意思：相同课程，找到 sc1 成绩比 sc 成绩大的学号数量，然后得到排序列。以 1 号课程为例，遍历每个学号，找到比这个学号成绩高的学生的数量再加 1 就是排名。这是 1 号课程的所有学生的成绩：\nsc 表第一行成绩为 80 的学生表（无色行），到 sc1 表中找没有比 80 大的，所以排名是 0；\nsc 表第二行成绩为 70 的学生表（浅黄色行），到 sc1 表中有 3 个比 70 大的（深黄色行），所以排名是 3；\nsc 表第四行成绩为 50 的学生表（浅绿色行），到 sc1 表中有 4 个比 50 大的（深绿色行），所以排名是 4；\nsc 表第五行成绩为 76 的学生表（浅蓝色行），到 sc1 表中有 2 个比 76 大的（深蓝色行），所以排名是 2；\nsc 表第六行成绩为 50 的学生表（浅灰色行），到 sc1 表中有 5 个比 31 大的（深灰色行），所以排名是 5；\n因为排名是从 0 开始的，所以最后（2，3）名变成 in（1，2）最大的排前面属于降序。如果SUM(sc.score<score)变成大于号就从 sc1 中找到成绩小于 sc 表成绩的学生数量。方法三：都各自查出来，再纵向连接（最笨的方法）\n( SELECT stu.*, sc.score FROM stu\n\t\tJOIN sc ON stu.s_id = sc.s_id\n\tWHERE c_id = '01'\n\tORDER BY score DESC\n\t\tLIMIT 1, 2\n) UNION\n( SELECT stu.*, sc.score FROM stu\n\t\tJOIN sc ON stu.s_id = sc.s_id\n\tWHERE c_id = '02'\n\tORDER BY score DESC\n\t\tLIMIT 1, 2\n) UNION\n( SELECT stu.*, sc.score FROM stu\n\t\tJOIN sc ON stu.s_id = sc.s_id\n\tWHERE c_id = '03'\n\tORDER BY score DESC\n\t\tLIMIT 1, 2\n);","13-按各科成绩进行排序并显示排名#13. 按各科成绩进行排序，并显示排名":"与 12 题一样。方法一：窗口函数\nSELECT stu.s_name, sc.c_id, sc.score,\n\tRANK() over ( PARTITION BY sc.c_id ORDER BY sc.score ) AS ranks\nFROM stu\n\tJOIN sc ON stu.s_id = sc.s_id;\n方法二：关联子查询\nSELECT stu.s_name, sc.c_id, sc.score,\n\t(\n\t\tSELECT SUM( sc.score < sc1.score )\n\t\tFROM sc AS sc1\n\t\tWHERE sc.c_id = sc1.c_id\n\t) + 1 AS ranks\nFROM sc\n\tJOIN stu ON sc.s_id = stu.s_id\nORDER BY c_id, ranks;","其他类型查询#其他类型查询":"","集合运算查询#集合运算查询":"合并查询是使用 UNION 操作符将来自不同查询的数据组合起来，形成一个具有综合信息的查询结果。UNION 操作会自动将重复的数据行剔除。必须注意的是，参加合并查询的各子查询的使用的表结构应该相同，即各子查询中的数据数目和对应的数据类型都必须相同。如：从 SC 数据表中查询出学号为“S1”同学的学号和总分，再从 SC 数据表中查询出学号为“S5”的同学的学号和总分，然后将两个查询结果合并成一个结果集。\nSELECT SNo AS 学号, SUM(Score) AS 总分 FROM SC\n    WHERE (SNo = 'S1')\n    GROUP BY SNo\nUNION SELECT SNo AS 学号, SUM(Score) AS 总分 FROM SC\n\tWHERE (SNo = 'S5')\n\tGROUP BY SNo","存储查询结果到表中#存储查询结果到表中":"使用 SELECT...INTO 语句可以将查询结果存储到一个新建的数据库表或临时表中。如：从 SC 数据表中查询出所有同学的学号和总分，并将查询结果存放到一个新的数据表 Cal_Table 中。\nSELECT SNo AS 学号, SUM(Score) AS 总分\nINTO Cal_Table\nFROM SC GROUP BY SNo\n如果在本例中，将 INTO Cal_Table 改为 INTO #Cal_Table，则查询的结果被存放到一个临时表中， 临时表只存储在内存中，并不存储在数据库中，所以其存在的时间非常短。","数据表中数据的操纵#数据表中数据的操纵":"","添加数据表中的数据#添加数据表中的数据":"添加数据是把新的记录添加到一个已存在的表中。添加数据使用的 SQL 命令是 INSERT INTO，可分为以下几种情况。（1）添加一行新记录。添加一行新记录的语法格式为：\nINSERT INTO <表名> (<列名 1> [,<列名 2>...]) VALUES <值>\n其中，<表名> 是指要添加新记录的表，<列名> 是可选项，指定待添加数据的列，VALUES 子句指定待添加数据的具体值。列名的排列顺序不一定要和表定义时的顺序一致，但当指定列名时，VALUES 子句中值的排列顺序必须和列名表中的列名排列顺序一致，个数相等，数据类型一一对应。如：在 S 表中添加一条学生记录（学号：S7，姓名：郑冬，性别：女，年龄：21，系别：计算机）。\nINSERT INTO S (SNo, SN, Age, Sex, Dept)\nVALUES ('S7', '郑冬', 21, '女', '计算机')\n必须用逗号将各个数据分开，字符型数据要用单引号括起来。如果 INTO\n子句中没有指定列名，则新添加的记录必须在每个属性列上均有值，且 VALUES\n子句中值的排列顺序要和表中各属性列的排列顺序一致。\n（2）添加一行记录的部分数据值。如：在 SC 表中添加一条选课记录 ('S7', 'C1')。\nINSERT INTO SC (SNo, CNo) VALUES ('S7', 'C1')\n将 VALUES 子句中的值按照 INTO 子句中指定列名的顺序添加到表中，对于 INTO 子句中没有出现的列，则新添加的记录在这些列上将赋 NULL 值，如上例的 Score 即赋 NULL 值。但在表定义时有 NOT NULL 约束的属性列不能取 NULL 值，插入时必须给其赋值。(3) 添加多行记录。添加多行记录用于表间的复制，即将一个表中的数据抽取数行添加到另一个表中，可以通过子查询来实现。如：求出各系教师的平均工资，把结果存放在新表 AvgSal 中。\n-- 首先，建立新表 AvgSal，用来存放系名和各系的平均工资。\nCREATE TABLE AvgSal (\n    Department VARCHAR(20),\n    Average SMALLINT)\n-- 然后，利用子查询求出 T 表中各系的平均工资，把结果存放在新表 AvgSal 中。\nINSERT INTO AvgSal\n\tSELECT Dept, AVG(Sal) FROM T\n\tGROUP BY Dept","修改数据表中的数据#修改数据表中的数据":"可以使用 SQL 的 UPDATE 语句对表中的一行或多行记录的某些列值进行修改，其语法格式为：\nUPDATE <表名>\nSET <列名>=<表达式> [,<列名>=<表达式>]... [WHERE <条件>]\n其中，<表名> 是指要修改的表，SET 子句给出要修改的列及其修改后的值。WHERE 子句指定待修改的记录应当满足的条件，WHERE 子句省略时，则修改表中的所有记录。\n-- （1）修改一行\n-- 把刘伟老师转到信息系。\nUPDATE T\nSET Dept = '信息' WHERE TN = '刘伟'\n-- （2）修改多行\n-- 将所有学生的年龄增加 1 岁。\nUPDATE S\nSET Age = Age + 1\n-- 把教师表中工资小于或等于 1000 元的讲师的工资提高 20%。\nUPDATE T\nSET Sal = 1.2 * Sal\n\tWHERE ( Prof = '讲师' ) AND ( Sal <= 1000 )\n-- （3）用子查询选择要修改的行。\n-- 把讲授 C5 课程的教师的岗位津贴增加 100 元。\nUPDATE T\nSET Comm = Comm + 100\n\tWHERE TNo IN (\n        SELECT TNo FROM T, TC\n        WHERE T.TNo = TC.TNo AND TC.CNo = 'C5')\n-- （4）用子查询提供要修改的值。\n-- 把所有教师的工资提高到平均工资的 1.2 倍。\nUPDATE T\nSET Sal = ( SELECT 1.2 * AVG(Sal) FROM T )","删除数据#删除数据":"使用 SQL 的 DELETE 语句可以删除表中的一行或多行记录，其语法格式为：\nDELETE FROM <表名> [WHERE <条件>]\n其中，<表名> 是指要删除数据的表。WHERE 子句指定待删除的记录应当满足的条件，WHERE 子句省略时，则删除表中的所有记录。\n-- （1）删除一行记录。\n-- 删除刘伟老师的记录。\nDELETE FROM T WHERE TN = '刘伟'\n-- （2）删除多行记录。\n-- 删除所有教师的授课记录。\nDELETE FROM TC\n-- 执行此语句后，TC 表即为一个空表，但其定义仍存在数据字典中。\n-- （3）利用子查询选择要删除的行。\n-- 删除刘伟老师授课的记录。\nDELETE FROM TC\nWHERE TNo = ( SELECT TNo FROM T WHERE TN = '刘伟' )","视图#视图":"视图通常用来集中、简化和自定义每个用户对数据库的不同认识。视图可用作安全机制，方法是允许用户通过视图访问数据，而不授予用户直接访问视图关联的基础表权限。视图可用于提供向后兼容接口来模拟曾经存在但其架构已更改的基础表。还可以在向 SQL Server 复制数据和从其中复 制数据时使用视图，以便提高性能并对数据进行分区。\nSQL VIEW（视图） - 知乎 (zhihu.com)","什么是视图#什么是视图？":"在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。视图包含行和列，就像一个真实的表。\n视图是一种不存在的虚拟表: 类似表但是不是表。\n类似表: 视图有表结构；\n不是表: 没有数据, 视图的数据来源都是基表；\n视图中的字段是来自一个或多个数据库中的真实的表中的字段。\n单表视图: 基表只有一个；\n多表视图: 基表至少两个以上；\n我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据，就像这些来自于某个单一的表。\n数据库的设计和结构不会受到视图中的函数、WHERE 或 JOIN 语句的影响。\n视图总是显示最近的数据。每当用户查询视图时，数据库引擎通过使用 SQL 语句来重建数据。\n可以从某个查询内部、某个存储过程内部，或者从另一个视图内部来使用视图。通过向视图添加函数、JOIN 等等，我们可以向用户精确地提交我们希望提交的数据。","sql-create-view-实例#SQL CREATE VIEW 实例":"SQL CREATE VIEW 语法：\nCREATE VIEW view_name AS\nSELECT column_name(s) FROM table_name\nWHERE condition\n实例：\n-- 创建视图\ncreate or replace view v_student as\nselect Sno,Sname\nfrom student;\n-- 从视图中检索数据，即查询上面这个视图\nselect * from v_student;\n-- 也可以向查询添加条件\nselect *\nfrom v_student\nwhere Sname like '%云';\n-- 删除视图\ndrop view v_student;","视图的作用#视图的作用":"简化了操作，把经常使用的数据定义为视图，可以将复杂的 SQL 查询语句进行封装。如在实际工作中，不同的人员只关注与其相关的数据，而与他无关的数据，对他没有任何意义。根据这一情况，可以专门为其创建一个视图，定制用户数据，聚焦特定的数据。此后当他查询数据时，只需 select * from view_name; 就可以了。\n安全性，用户只能查询和修改能看到的数据。使用视图，基表中的数据就有了一定的安全性。因为视图是虚拟的，物理上是不存在的，只是存储了数据的集合，我们可以不通过视图将基表中重要的字段信息给用户。视图是动态的数据的集合，数据是随着基表的更新而更新的。同时，用户对视图，不可以随意的更改和删除，可以保证数据的安全性。方便了权限管理，让用户对视图有权限而不是对底层表有权限进一步加强了安全性\n逻辑上的独立性，屏蔽了真实表的结构带来的影响。视图的存在: 主要是为了对外提供数据支持(外部系统)；隐藏了基表字段(隐私)；保证了数据库的数据安全(保护数据库内部的数据结构)；可以灵活的控制对外的数据: 保证针对每个接口都有一个单独的数据支持，增强了用户友好性。","视图的缺点#视图的缺点":"性能差数据库必须把视图查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么即使是视图的一个简单查询，数据库也要把它变成一个复杂的结合体，需要花费一定的时间。\n修改限制\n当用户试图修改视图的某些信息时，数据库必须把它转化为对基本表的某些信息的修改，对于简单的视图来说，这是很方便的，但是，对于比较复杂的试图，可能是不可修改的。\n在定义数据库对象时，不能不加选择地来定义视图，应该权衡视图的优点和缺点，合理地定义视图。\ntip 对视图的修改\n单表视图操作: 可以进行增删改, 但是要实现新增: 前提是视图必须包含基表的所有不能为空的字段。\n多表视图(基表来源两个以上)不能插入数据, 也不能删除数据，但是可以修改数据。\n使用视图还是有很多局限性的，并没有像直接使用表那么方便。如果视图定义中包含了 group by、union、聚合函数以及其他一些特殊情况，就不能被更新了；更新视图的查询也可以是一个关联语句，但是被更新的列必须来自同一张表；而且所有使用临时表算法实现的视图都无法被更新。","创建视图#创建视图":"可以使用 SQL 语句 CREATE VIEW 创建视图，其语法格式为：\nCREATE VIEW view_name (column [ ,...n ])\n\t[WITH <view_attribute> [ ,...n ]]\nAS select_statement [WITH CHECK OPTION] [;]\n<view_attribute> ::=\n{\n\t[ENCRYPTION]\n\t[SCHEMABINDING]\n\t[VIEW_METADATA]\n}\n其中：\nview_name：视图的名称，必须符合 SQL Server 的标识符命名规则。\ncolumn：视图的列名称。仅在下列情况下需要列名：列是从算术表达式、函数或常量派生的；两个或更多的列可能会具有相同的名称（通常是由于联接的原因）；视图中的某个列的指定名称不同于其派生来源列的名称。\nselect_statement：定义视图的 SELECT 语句。该语句可以使用多个表和其他视图。\nCHECK OPTION：设置针对视图的所有数据修改语句都必须符合 select_statement 中规定的条件。\nENCRYPTION：视图是加密的，如果加上这个选项，则无法修改视图。因此，创建视图时需要将脚本保存，否则再也不能修改了。\nSCHEMABINDING：和底层引用的表进行定义绑定。加上这个选项的话，则视图引用的表不能随便更改构架（例如列的数据类型），如果需要更改底层表构架，则先 DROP 或者 ALTER 在底层表之上绑定的视图。SCHEMABINDIN 常用于定义索引视图。\nVIEW_METADATA：不设置该选项，返回给客户端的 metadata 是视图所引用表的 metadata。设置了该选项，则返回视图自身的 metadata。通俗点说，VIEW_METADATA 可以让视图看起来貌似表一样，视图的每一列的定义直接告诉客户端，而不是所引用的底层表列的定义。\n如：创建一个计算机系教师情况的视图 Sub_T。\nCREATE VIEW Sub_T AS\n\tSELECT TNo, TN, Prof FROM T WHERE Dept = '计算机'\n视图名字为 Sub_T，省略了视图字段列表。视图由子查询中的三列 Tno、TN 和 Prof 组成。视图创建后，对视图 Sub_T 的数据的访问只限制在“计算机系”内，且只能访问 TNo、TN 和 Prof 三列的内容，从而达到了数据保密的目的。又如：创建一学生情况视图 S_SC_C（包括学号、姓名、课程名及成绩）。\nCREATE VIEW S_SC_C(SNo, SN, CN, Score) AS\n\tSELECT S.SNo, SN, CN, Score FROM S, C, SC\n\tWHERE S.SNo = SC.SNo AND SC.CNo = C.CNo\n-- 此视图由三个表连接得到，在 S 表和 SC 表中均存在 SNo 列，故需指定视图列名。","修改视图#修改视图":"可以使用 SQL 的 ALTER VIEW 语句修改视图，其语法格式为：\nALTER VIEW <视图名>[(<视图列表>)] AS <子查询>\n如：修改学生情况视图 S_SC_C（包括姓名、课程名及成绩）。\nALTER VIEW S_SC_C(SN, CN, Score)\nAS SELECT SN, CN, Score\n\tFROM S, C, SC\n\tWHERE S.SNo = SC.SNo AND SC.CNo = C.CNo","删除视图#删除视图":"删除视图的语法格式为：\nDROP VIEW <视图名>\n如：删除计算机系教师情况的视图 Sub_T。\nDROP VIEW Sub_T\n视图删除后，只会删除该视图在数据字典中的定义，而与该视图有关的基本表中的数据不会受任何影响，由此视图导出的其他视图的定义不会删除，但已无任何意义。用户应该把这些视图删除。","查询视图#查询视图":"视图定义后，对视图的查询操作如同对基本表的查询操作一样。如：查询视图 Sub_T 中职称为教授的教师号和姓名。\nSELECT TNo, TN FROM Sub_T\nWHERE Prof = '教授'\n此查询的执行过程是系统首先从数据字典中找到 Sub_T 的定义，然后把此定义和用户的查询结合起来，转换成等价的对基本表 T 的查询，这一转换过程称为视图消解（View Resolution），相当于执行以下查询：\nSELECT TNo,TN FROM T\nWHERE Dept = '计算机' AND Prof= '教授'\n由上例可以看出，当对一个基本表进行复杂的查询时，可以先对基本表建立一个视图，然后只需对此视图进行查询，这样就不必再键入复杂的查询语句，而将一个复杂的查询转换成一个简单的查询，从而简化了查询操作。","更新视图#更新视图":"由于视图是一张虚表，所以对视图的更新，最终转换成对基本表的更新。其更新操作包括添加、修改和删除数据，其语法格式与对基本表的更新操作一样。有些更新在理论上是不可能的，有些实现起来比较困难，如来自于多个基本表的视图。以下仅考虑可以更新的视图。\n添加（INSERT）如：向计算机系教师视图 Sub_T 中添加一条记录（教师号：T6、姓名：李丹、职称： 副教授）。\nINSERT INTO Sub_T (TNo, TN, Prof)\nVALUES ('T6', '李丹', '副教授')\n系统在执行此语句时，首先从数据字典中找到 Sub_T 的定义，然后把此定义和添加操作结合起来，转换成等价的对基本表 T 的添加。相当于执行以下操作：\nINSERT INTO T (TNo, TN, Prof)\nVALUES ('T6', '李丹', '副教授')\n修改（UPDATE）如：将计算机系教师视图 Sub_T 中刘伟的职称改为“副教授”。\nUPDATE Sub_T SET Prof = '副教授'\nWHERE (TN = '刘伟')\n转换成对基本表的修改操作：\nUPDATE T SET Prof = '副教授'\nWHERE TN = '刘伟' AND Dept = '计算机'\n删除（DELETE）如：删除计算机系教师视图 Sub_T 中刘伟老师的记录。\nDELETE FROM Sub_T WHERE TN = '刘伟'\n转换成对基本表的删除操作：\nDELETE FROM T WHERE Dept = '计算机' AND TN = '刘伟'","创建与使用索引#创建与使用索引":"索引是一种可以加快检索的数据库结构，它包含从表或视图的一列或多列生成的键，以及映射到指定数据存储位置的指针。通过创建设计良好的索引，可以显著提高数据库查询和应用程序的性能。从某种程度上说，可以把数据库看作一本书，把索引看作书的目录。借助目录查找信息，显然比没有目录的书方便快捷。除提高检索速度外，索引还可以强制表中的行具有唯一性，从而确保数据的完整性。\nMySQL 索引详解（一文搞懂）-阿里云开发者社区 (aliyun.com)\n索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。\n一种能帮助 mysql 提高了查询效率的数据结构：索引数据结构。","索引原理#索引原理":"索引的存储原理大致可以概括为一句话：以空间换时间。一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往是存储在磁盘上的文件中的（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。数据库在未添加索引进行查询的时候默认是进行全文搜索，也就是说有多少数据就进行多少次查询，然后找到相应的数据就把它们放到结果集中，直到全文扫描完毕。","索引的分类#索引的分类":"聚集索引：\n聚集索引的意思可以理解为顺序排列。\n因为数据库中的数据只能按照一个顺序进行排列，所以聚集索引一个数据库只能有一个。在 mysql 中，不能自己创建聚集索引，主键即为聚集索引，如果没有创建主键，那么默认非空的列为聚集索引，如果没有非空的列那么会自动生成一个隐藏列为聚集索引。\n非聚集索引：\n非聚集索引可以简单理解为有序目录，是一种以空间换取时间的方法。\n为指定列增加非聚集索引，添加了非聚集索引后，会给指定列进行排序（而不是只有主键有排序）。\n在非聚集索引中，不重复的数据越多，那么索引的效率越高。\n唯一索引：\n索引列的值必须唯一，但允许有空值（Null），但只允许有一个空值（Null）。\n视图索引：\n视图也称为虚表，由视图返回的结果集格式与基本表相同，都由行和列组成，在 SQL 语句中使 用视图与使用基本表的方式相同。标准视图的结果集不是永久地存储在数据库中的。每次查询引用 标准视图时，SQL Server 会在内部将视图的定义替换为该查询，直到修改后的查询仅引用基本表。\n对标准视图而言，查询动态生成的结果集开销很大，特别是涉及对大量行进行复杂处理的视图。如果很少更新基础表数据，则索引视图的使用效果最佳。如果经常更新基础表数据，维护索引 视图的开销可能超过使用索引视图所带来的性能收益。\n复合索引：\n一个索引可以包含多个列，多个列共同构成一个复合索引。\n全文索引：\nFull Text（MySQL5.7 之前，只有 MYISAM 存储引擎引擎支持全文索引）。\n全文索引类型为 FULLTEXT，在定义索引的列上支持值的全文查找允许在这些索引列中插入重复值和空值。全文索引可以在Char、VarChar 上创建。\n空间索引：\nMySQL 在 5.7 之后的版本支持了空间索引，而且支持 OpenGIS 几何数据模型，MySQL 在空间索引这方年遵循 OpenGIS 几何数据模型规则。\n前缀索引：\n在文本类型为 char、varchar、text 类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定。\nXML 索引：\n可以对 xml 数据类型列创建 XML 索引。XML 索引对列中 xml 实例的所有标记、值和路径进行索引，从而提高查询性能。\n适用于：对 xml 列进行查询在工作中很常见（但 xml 列没有被频繁修改）；xml 列的值相对较大，而检索的部分相对较小。","索引的优缺点#索引的优缺点":"优点：\n大大提高数据查询速度。\n可以提高数据检索的效率，降低数据库的 IO 成本，类似于书的目录。\n通过索引列对数据进行排序，降低数据的排序成本降低了 CPU 的消耗。\n被索引的列会自动进行排序，包括【单例索引】和【组合索引】，只是组合索引的排序需要复杂一些。\n如果按照索引列的顺序进行排序，对 order 不用语句来说，效率就会提高很多。\n缺点：\n索引会占据磁盘空间。\n索引虽然会提高查询效率，但是会降低更新表的效率。比如每次对表进行增删改查操作，MySQL 不仅要保存数据，还有保存或者更新对应的索引文件。\n维护索引需要消耗数据库资源。\n数据库表中不是索引越多越好，而是仅为那些常用的搜索字段建立索引效果最佳！","创建索引#创建索引":"MySQL 使用 CREATE INDEX 语句创建索引，既可以创建聚集索引，也可以创建非聚集索引；既可以在一列上创建索引，也可以在多列上创建索引。其基本的语法形式如下：\nCREATE [UNIQUE] [CLUSTERED|NONCLUSTERED]\nINDEX index_name\nON table_or_view_name (column_name [ASC|DESC] [,...n])\n[WITH <index_option> [,...n]]\n[ON {filegroup_name|\"default\"}]\n其中，UNIQUE 表示创建唯一索引，CLUSTERED 表示创建聚集索引，NONCLUSTERED 表示 创建非聚集索引。如：为表 SC 在 SNo 和 CNo 上建立唯一索引。\nCREATE UNIQUE INDEX SCI ON SC(SNo,CNo)\n执行此命令后，为 SC 表建立一个名为 SCI 的唯一索引，此索引为 SNo 和 CNo 两列的复合索引，即对 SC 表中的行先按 SNo 的递增顺序索引。对于相同的 SNo，又按 CNo 的递增顺序索引。由于有 UNIQUE 的限制，所以该索引在（SNo，CNo）组合列的排序上具有唯一性，不存在重复值。","修改索引#修改索引":"通常情况下，索引建立后由 DBMS 自动维护更新，无需手工干预，但有的情况下可能需要对索引进行修改。修改索引的 SQL 命令语法如下：\nALTER INDEX {index_name|ALL}\nON table_or_view_name\n{ REBUILD\n\t[\n        [PARTITION = ALL]\n        [WITH (<rebuild_index_option> [ ,...n ])]\n        | [PARTITION = partition_number\n          [WITH (<single_partition_rebuild_index_option> [,...n ])]\n    ]\n  | DISABLE\n  | REORGANIZE\n        [PARTITION = partition_number]\n        [WITH (LOB_COMPACTION = {ON|OFF})]\n  | SET (<set_index_option> [,...n])\n};\n主要参数的含义如下：\nREBUILD：删除索引并且重新生成索引，这样可以根据指定的填充度压缩页来删除磁盘碎片，回收磁盘空间，重新排序索引。\nPARTITION：指定只重新生成或重新组织索引的一个分区。如果 index_name 不是已分区索引，则不能指定 PARTITION。\nDISABLE：将索引标记为禁用，从而不能由数据库引擎使用。任何索引均可被禁用，已禁用索引的索引定义保留在没有基础索引数据的系统目录中。禁用聚集索引将阻止用户访问基础表数据。若要启用已禁用的索引，使用 ALTER INDEX REBUILD 或 CREATE INDEX WITH DROP_EXISTING 命令。\nREORGANIZE：重新组织索引，此子句等同于 DBCC INDEXDEFRAG。ALTER INDEX REORGANIZE 语句始终联机执行，这意味着不保留长期阻塞的表锁，对基础表的查询或更新可以在 ALTER INDEX REORGANIZE 事务处理期间继续执行。不能为已禁用的索引指定 REORGANIZE。","删除索引#删除索引":"在 SQL 中，可以使用 DROP INDEX 删除索引。语法格式如下：\nDROP INDEX <table or view name>.<index name>\n也可以使用如下的语法格式：\nDROP INDEX <index name> ON <table or view name>\n上述语句中，index_name 表示要删除的索引名，table_or_view_name 表示当前索引基于的表名或者视图名。","查看索引#查看索引":"用 Sp_helpindex 存储过程查看索引：Sp_helpindex 存储过程可以返回表中的所有索引信息，其语法如下：\nSp_helpindex [@objname =] 'name'\n其中，[@objname =] 'name' 子句指定当前数据库中的表名。如：查看表 SC 的索引。\nEXEC Sp_helpindex SC\n如果要更改索引名称，可利用 Sp_rename 存储过程更改，其语法如下：\nSp_rename '数据表名.原索引名', '新索引名'\n如：更改 T 表中的索引 TI 名称为 T_Index。\nEXEC Sp_rename 'T.TI', 'T_Index'"}},"/06-db-design":{"title":"第 6 章 数据库设计","data":{"数据库设计概述#数据库设计概述":"","数据库设计的任务内容和特点#数据库设计的任务、内容和特点":"数据库设计的任务：数据库设计是指根据用户需求研制数据库结构的过程。数据库设计的内容：\n数据库的结构设计：根据给定的应用环境，进行数据库的子模式或模式的设计。数据库模式是各应用程序共享的结构，是静态的、稳定的， 一经形成后通常情况下是不容易改变的，所以结构设计又称为静态模型设计。\n数据库的行为设计：确定数据库用户的行为和动作。用户的行为总是使数据库的内容发生变化，所以行为设计是动态的，行为设计又称为动态模型设计。\n数据库设计的特点：强调结构设计与行为设计相结合，是一种“反复探寻，逐步求精” 的过程。首先从数据模型开始设计，以数据模型为核心进行展开，将数据库设计和应用系统设计相结合，建立一个完整、独立、共享、冗余小和安全有效的数据库系统。","数据库设计方法简述#数据库设计方法简述":"据库设计方法目前可分为四类：直观设计法、规范设计法、计算机辅助设计法和自动化设计法。直观设计法也称为手工试凑法，它是最早使用的数据库设计方法，但这种方法越来越不适应信 息管理发展的需要。为了改变这种情况，各国数据库专家在美国新奥尔良（New Orleans）市专门讨论了数据库设计问题，新奥尔良法将数据库设计分成需求分析（分析用户需求的数据及数据的联系）、概念结构设计（信息分析和定义）、逻辑结构设计 （设计实现）和物理结构设计（物理数据库设计）。目前，常用的规范设计方法大多起源于新奥尔良法，并在设计的每一阶段采用一些辅助方法来具体实现。下面简单介绍几种常用的规范设计方法。\n基于 E-R 模型的数据库设计方法基于 E-R 模型的数据库设计方法是由 P.P.S.Chen 于 1976 年提出的数据库设计方法，其基本思想是在需求分析的基础上，用 E-R（实体-联系）图构造一个反映现实世界实体之间联系的企业模式，即概念模式，并进而将此企业模式转换成基于某一特定的 DBMS 的物理模式。\n基于 3NF 的数据库设计方法基于 3NF 的数据库设计方法是由 S·Atre 提出的结构化设计方法，其基本思想是在需求分析的 基础上，确定数据库模式中的全部属性和属性间的依赖关系，将它们组织在一个单一的关系模式中， 然后再分析模式中不符合 3NF 的约束条件，将其进行投影分解，规范成若干个 3NF 关系模式的集合。\n基于视图的数据库设计方法基于视图的数据库设计方法先从分析各个应用的数据着手，并为每个应用建立自己的视图，然 后再把这些视图汇总起来合并成整个数据库的概念模式。\n除了以上三种方法外，规范化设计方法还有实体分析法、属性分析法和基于抽象语义的设计方 法等，这里不再详细介绍。计算机辅助设计法是指在数据库设计的某些过程中模拟某一规范化设计的方法，并以人的知识或经验为主导，通过人机交互方式实现设计中的某些部分。目前许多计算机辅助软件工程（Computer Aided Software Engineering，CASE）工具可以自动或辅助设计人员完成数据库设计过程中的很多任务，如 Sybase 公司的 PowerDesigner 和 Premium 公司的 Navicat 等。现代数据库设计方法是上述设计方法相互融合的产物。围绕软件工程的思想和方法，通常以 E-R 图设计为主体，辅以 3NF 设计和视图设计实现模式的评价和模式的优化，从而吸收各种设计方法的优势。同时，为提高设计的协同效率和规范化程度，现代数据库设计过程还会通过计算机辅助设计工具（如 PowerDesigner 等）获得规范的数据库设计结果。","系统需求分析#系统需求分析":"需求分析是数据库设计的起点，为以后的具体设计做准备。","需求分析的任务#需求分析的任务":"从数据库设计的角度来看，需求分析的任务是：对现实世界要处理的对象（组织、部门、企业）等进行详细的调查，通过对原系统的了解，收集支持新系统的基础数据并对其进行处理，在此基础上确定新系统的功能。具体地说，需求分析阶段的任务包括下述三项。\n调查分析用户活动\n收集和分析需求数据，确定系统边界\n编写系统分析报告","需求分析的方法#需求分析的方法":"用户参加数据库设计是数据系统设计的特点，是数据库设计理论不可分割的一部分。用于需求分析的方法有多种，主要方法有自顶向下和自底向上两种。其中自顶向下的分析方法（又称结构化分析方法，Structured Analysis，SA）是最简单实用的方 法。SA 方法从最上层的系统组织机构入手，采用逐层分解的方式分析系统，用数据流图（Data Flow Diagram，DFD）和数据字典（Data Dictionary，DD）描述系统。下面对数据流图和数据字典作些简单的介绍。","数据流图#数据流图":"使用 SA 方法，任何一个系统都可抽象为下图所示的数据流图。在数据流图中，用命名的箭头表示数据流，用圆圈表示处理，用不封闭的矩形或其他形状表示存储，使用封闭的矩形表示数据来源和输出。下图是一个简单的数据流图。一个简单的系统可用一张数据流图来表示。当系统比较复杂时，为了便于理解，控制其复杂性，可以采用分层描述的方法。一般用第一层描述系统的全貌，第二层分别描述各子系统的数据流。如果系统结构还比较复杂，那么，可以继续细化，直到表达清楚为止。在处理功能逐步分解的同时，它们所用的数据也逐级分解，形成若干层次的数据流图。数据流图表达了数据和处理过程的关系。","数据字典#数据字典":"暂时不写","概念结构设计#概念结构设计":"","概念结构设计的必要性#概念结构设计的必要性":"在需求分析阶段，设计人员充分调查并描述了用户的需求，但这些需求只是现实世界的具体要 求，应把这些需求抽象为信息世界的信息结构，才能更好地实现用户的需求。概念结构设计就是将需求分析得到的用户需求抽象为信息结构，即概念模型。本阶段目的：\nAn abundance of data required to meet organization’s information needs 满足组织信息需求所需的丰富数据\nGoal: Organise the data to store, update, and query eﬀectively and eﬃciently 组织数据以有效、高效地存储、更新和查询\nIterative Database Design 迭代数据库设计：\n收集所有的需求\n将需求结构化为原子性的信息\n类型和它们之间的关系\n将概念性的东西转化为关系性的模型\n在物理层面上实施关系模型\n将物理变化映射到逻辑模型上\n将物理变化映射到概念模型上\n将逻辑变化映射到概念模型上\n重点关注概念模型及其\n转化为逻辑模型\n如：From Requirements to a First Approximate Model 从需求到第一个近似模型Input: information requirements of the users 用户的信息需求Output is a database schema:\nconsolidation of all user requirements, but 所有用户需求的整合，但\ndoes not yet contain any layout considerations 还没有包含任何布局考虑\nin terms of relational tables 在关系表方面的布局考虑\nnor implementation details in terms of physical storage structures 也没有物理存储结构方面的实施细节\nConceptual data model 概念数据模型: provides the language for describing the database schema 提供了用于描述数据库模式的语言","概念模型的特点#概念模型的特点":"概念模型作为概念结构设计的表达工具，为数据库提供一个说明性结构，是设计数据库逻辑结构即逻辑模型的基础。因此，概念模型必须具备以下特点。\n语义表达能力丰富。概念模型能表达用户的各种需求，充分反映现实世界，包括事物和事物之间的联系、用户对数据的处理要求，它是现实世界的一个真实模型。\n易于交流和理解。概念模型是 DBA、设计人员和用户之间的主要界面，因此，概念模型的表达要自然、直观和容易理解，以便和不熟悉计算机的用户交换意见。\n易于修改和扩充。概念模型要能灵活地加以改变，以反映用户需求和现实环境的变化。\n易于向各种数据模型转换。概念模型独立于特定的 DBMS，因而更加稳定，能方便地向关系模型、网状模型或层次模型等各种数据模型转换。\n人们提出了许多概念模型，其中最著名、最实用的一种是 E-R 模型，它将现实世界的信息结构统一用属性、实体以及它们之间的联系来描述。\nThe Entity-Relationship Model is the most widely used conceptual data model 实体关系模型是使用最广泛的概念数据模型。","概念模型的-e-r-表示方法#概念模型的 E-R 表示方法":"在概念模型中，比较著名的是由 P.P.Chen 于 1976 年提出的实体联系模型（Entity Relationship Model），简称 E-R 模型。E-R 模型是广泛应用于数据库设计工作中的一种概念模型，它利用 E-R 图来表示实体及其之间的联系。E-R 图的基本成分包含实体型、属性和联系，它们的表示方式如下。\n实体型：用矩形框表示，框内标注实体名称，如图（a）所示。\n属性：用椭圆形框表示，框内标注属性名称，并用无向边将其与相应的实体相连，如图（b）所示。\n联系：联系用菱形框表示，框内标注联系名称，并用无向边与有关实体相连，同时在无向 边旁标上联系的类型，即 1:1、1:n 或 m:n，如图（c）所示。\n实体之间的联系有一对一（1:1）、一对多（1:n）和多对多（m:n）三种联系类型。例如，系主任 领导系、学生属于某个系、学生选修课程、工人生产产品，这里“领导”“属于”“选修”“生产”表示实体间的联系，可以作为联系名称。现实世界的复杂性导致实体联系的复杂性，表现在 E-R 图上可以归结为下图所示的几种基本形式。\n两个实体型之间的联系，如图（a）所示。\n两个以上实体型间的联系，如图（b）所示。\n同一实体集内部各实体之间的联系，例如一个部门内的职工有领导与被领导的联系，即某一 职工（干部）领导若干名职工，而一个职工（普通员工）仅被另外一个职工直接领导，这就构成了 实体内部的一对多的联系，如图（c）所示。\n需要注意的是，因为联系本身也是一种实体型，所以联系也可以有属性。如果一个联系具有属性，则这些联系也要用无向边与该联系的属性连接起来。例如，学生选修的课程有相应的成绩。这里的“ 成绩”既不是学生的属性，也不是课程的属性，只能是学生选修课程的联系的属性，如图（a）所示。E-R 图的基本思想就是分别用矩形框、椭圆形框和菱形框表示实体型、属性和联系，使用无向边将属性与其相应的实体连接起来，并将联系和有关实体相连接，注明联系类型。图 6-12 所示为几个 E-R 图的例子，只给出了实体及其 E-R 图，省略了实体的属性。下图所示为一个描述学生与课程联系的完整的 E-R 图。"}},"/05-ds-security-protect":{"title":"第 5 章 数据库安全保护","data":{"数据库的安全性#数据库的安全性":"","数据库安全性的含义#数据库安全性的含义":"数据库的安全性是指保护数据库以防止非法使用所造成的数据泄露、更改或破坏。安全性问题有许多方面，其中包括：\n法律、社会和伦理方面的问题，如请求查询信息的人是不是有合法的权力；\n物理控制方面的问题，如计算机房是否应该加锁或用其他方法加以保护；\n政策方面的问题，如确定存取原则，允许指定用户存取指定数据；\n运行方面的问题，如使用口令时，如何使口令保密；\n硬件控制方面的问题，如 CPU 是否提供任何安全性方面的功能诸如存储保护键或特权工作 方式；\n操作系统安全性方面的问题，如在主存储器和数据文件用过以后，操作系统是否把它们的 内容清除掉；\n数据库系统本身的安全性方面的问题。\n这里讨论的是数据库本身的安全性问题，主要考虑安全保护的策略，尤其是控制访问的策略。","安全性控制的一般方法#安全性控制的一般方法":"安全性控制是指要尽可能地杜绝所有可能的数据库非法访问。实际上，安全性问题并不是数据系统所独有的，所有计算机系统都存在这个问题。在计算机系统中，安全措施是一级一级层层设置的，安全控制模型下图所示。后面我们只讨论数据库有关的用户标识和鉴定、用户存取权限控制、定义视图、数据加密和审计等几类安全性措施。\n用户标识和鉴定数据库系统是不允许一个未经授权的用户对数据库进行操作的。用户标识和鉴定是系统提供的最外层的安全保护措施，其方法是由系统提供一定的方式让用户标识自己的名字或身份，系统内部记录着所有合法用户的标识，每次用户要求进入系统时，由系统进行核实，通过鉴定后才提供计算机的使用权。用户标识和鉴定的方法一般有：\n用一个用户名或用户标识符来标明用户的身份，系统以此来鉴别用户的合法性。\n用户标识符是用户公开的标识，它不足以成为鉴别用户身份的凭证。为了进一步核实用户身份，常采用用户名（Username）与口令（Password）相结合的方法，系统通过核对口令判别用户身份的真伪。\n通过用户名和口令来鉴定用户的方法简单易行，但该方法在使用时，由于用户名和口令的产生和使用比较简单，也容易被窃取，因此还可采用更复杂的方法。例如，每个用户都预先约定好一个过程或者函数，鉴别用户身份时，系统提供一个随机数，用户根据自己预先约定的计算过程或者函数进行计算，系统根据计算结果辨别用户身份的合法性。\n用户存取权限控制用户存取权限指的是不同的用户对于不同的数据对象允许执行的操作权限。在数据库系统中，每个用户只能访问他有权存取的数据并执行有权使用的操作。因此，系统必须预先定义用户的存取权限。在数据库系统中，定义用户存取权限称为授权（Authorization）。用户的存取权限有两种：系统权限和对象权限。系统权限是由 DBA 授予某些数据库用户，只有得到系统权限，才能成为数据库用户。对象权限可以由 DBA 授予，也可以由数据对象的创建者授予，使数据库用户具有对某些数据对象进行某些操作的权限。\n定义视图为不同的用户定义不同的视图，可以限制各个用户的访问范围。通过视图机制把要保密的数据对无权存取这些数据的用户隐藏起来，从而自动地对数据提供一定程度的安全保护。但视图机制的安全保护功能太不精细，往往不能达到应用系统的要求，其主要功能在于提供了数据库的逻辑独立性。在实际应用中，通常将视图机制与授权机制结合起来使用，首先用视图机制屏蔽一部分保密数据，然后在视图上再进一步定义存取权限。\n数据加密前面介绍的几种数据库安全措施，都是防止从数据库系统窃取保密数据，不能防止通过不正常渠道非法访问数据。例如，偷取存储数据的磁盘，或在通信线路上窃取数据。为了防止这些窃密活动，比较好的办法是对数据加密。数据加密（Data Encryption）是防止数据库中数据在存储和传输中失密的有效手段。加密的基本思想是根据一定的算法将原始数据（术语为明文，Plain Text）加密成为不可直接识别的格式（术语为密文，Cipher Text），数据以密文的形式存储和传输。加密方法有两种，一种是替换方法，该方法使用密钥（Encryption Key）将明文中的每一个字符转换为密文中的字符。另一种是转换方法，该方法将明文中的字符按不同的顺序重新排列。通常将这两种方法结合起来使用，就可以达到相当高的安全程度。例如，美国 1977 年制定的官方加密标准——数据加密标准（Data Encryption Standard，DES），就是使用这种算法的例子。\n审计（Audit）前面介绍的各种数据库安全性措施，都可将用户操作限制在规定的安全范围内，但实际上任何系统的安全性措施都不是绝对可靠的，窃密者总有办法打破这些控制。对于某些高度敏感的保密数据，必须以审计作为预防手段。审计功能是一种监视措施，它跟踪记录有关数据的访问活动。使用审计功能把用户对数据库的所有操作自动记录下来，存放在一个特殊文件中，即审计日志（Audit Log）中。记录的内容一般包括：操作类型（如修改、查询等）、操作终端标识与操作者标识、操作日期和时间、操作所涉及的相关数据（如基本表、视图、记录、属性等）、数据的前象和后象等。利用这些信息，可以重现导致数据库现有状况的一系列事件，以进一步找出非法存取数据的人、时间和内容等。使用审计功能会大大增加系统的开销，所以 DBMS 通常将其作为可选特征，并提供相应的操作语句，可灵活地打开或关闭审计功能。例如，可使用如下 SQL 语句打开对表 S 的审计功能，对表 S 的每次成功的查询、增加、删除和修改操作都作审计追踪：\nAUDIT SELECT,INSERT,DELETE,UPDATE ON S\nWHENEVER SUCCESSFUL\n要关闭对表 S 的审计功能可以使用如下语句：\nNO AUDIT ALL ON S","数据安全性机制#数据安全性机制":"安全模型上分为三层结构，分别为服务器安全管理、数据库安全管理和数据库 对象的访问权限管理。\n第一层安全性是系统服务器级别的安全性，这一级别的安全性建立在控制服务器登录账号和密码的基础上，即必须具有正确的服务器登录账号和密码才能连接到服务器/终端。\n第二层安全性是数据库级别的安全性，即检查是否具有访问某个数据库的权利。\n第三层安全性是数据库对象级别的安全性，用户通过了前两层的安全性验证之后，在对具体的数据库对象（表、视图、存储过程等）进行操作时，将接受权限检查，即用户想要访问数据库里的对象时，必须事先被赋予相应的访问权限，否则系统将拒绝访问。\n三个层次的安全机制相当于用户访问数据库对象过程中的三道安全屏障，只有合法地通过了这三个层次的安全验证，用户才能真正访问到相应的数据库对象。","safe-range-normal-form-srnf#Safe range normal form (SRNF)":"SRNF of a query Q does not change Q ’s meaning, it just checks if Q is safe.SRNF results from the application of transformation rules to formulae that preserve their meaning. SRNF 的结果来自于对保留其含义的公式应用转换规则。Transformation Rules:\nElimination of shortcuts(消除“快捷方式”): First eliminate shortcuts related to universal quantiﬁcation ∀, implication ⇒ and equivalence ⇔. 首先消除与全称量词 ∀、蕴涵符号 ⇒ 和等价符号 ⇔ 相关的快捷方式。\nBounded renaming(有界变量重命名): Change the names of bounded variables, i.e., those occurring within the scope of a quantiﬁer, in such a way that there is no variable which is both free and bound. 将有界变量的名称更改为在量词作用域内出现的那些变量的新名称，以便不存在即是自由变量又是绑定变量的变量。\nShift negation(移位否定符号): Successively replace subformulae in a way that negation only occurs in front of an existential quantiﬁer or an atom 逐步替换子公式，使得否定符号只出现在存在量词或原子之前:\nremove double negation, i.e., replace  by \nreplace  by \nreplace  by \nShift disjunction(移位析取符号): Successively apply the distribution laws for conjunction and disjunction until there is no more disjunction occurring within the scope of a conjunction. 连续地应用合取和析取的分配律，直到在合取范围内没有更多的析取。\nOmit parentheses(省略括号): Omit all parentheses that are unnecessary according to associativity laws. 根据结合律省略所有不必要的括号。\n需要注意的是，SRNF 的应用需要满足一定的前提条件，例如 Q 必须是一个具有良好形式化特性的查询，才能有效地进行 SRNF 转换。另外，在实际应用中，SRNF 也可能会引入一些新的问题，如计算复杂度、查询错误等。如：第一步：消除“快捷方式”第二步：移位否定符号第三步：继续消除“快捷方式”第四步：继续移位否定符号完成。Roughly speaking a formula is safe iﬀ all free variables in its SRNF are range-restricted. 总的来说，我们说一个关系演算公式是安全的，因为它的 SRNF 中的所有自由变量都受到范围限制。","interaction-between-query-languages#Interaction between Query Languages":"A Clever Way of Writing Difficult SQL Queries 编写困难 SQL 查询的聪明方法：\n在安全的关系演算中形式化查询\n将查询转换为 SRNF\n将 SRNF 转换为 SQL\n如：Hitchcock query in TRC in SRNF:Transformed into SQL:\nSELECT d1.name FROM Director d1\nWHERE NOT EXISTS(\n    SELECT d2.movie FROM Director d2\n    WHERE d2.name = d1.name AND NOT EXISTS(\n        SELECT * FROM Actor a1\n        WHERE a1.name = d2.name AND a1.movie = d2.movie\n        AND NOT EXISTS(\n            SELECT * FROM Actor a2\n            WHERE a2.role <> a1.role\n            AND a2.movie = a1.movie\n            AND a2.name = a1.name\n            )\n        )\n    )\nEach relational algebra query (except union) can be easily rewritten in SQL:\nattribute selection 属性选取：\nSELECT ∗ FROM R WHERE A = B;\nconstant selection 常数选取: ​\nSELECT ∗ FROM R WHERE A = c;\nprojection 投影: ​\nSELECT DISTINCT A1, ..., Ak FROM R;\nrenaming 命名: \nSELECT A1 AS B1 ,..., Ak AS Bk FROM R;\njoin 连接:  (with common attributes ​ )\nSELECT ∗ FROM R1, R2 WHERE R1.A1 = R2.A1\nAND ...\nAND R1.Ak = R2.Ak;\ndifference 减法:  (with attributes  )\nSELECT ∗ FROM R1 WHERE (A1, ..., Ak ) NOT IN R2;\nExtend SQL by relational expressions:\nUnion:\n<query> UNION <query>\nIntersection:\n<query> INTERSECT <query>\nDifference:\n<query> DIFFERENCE <query>\nJoin expressions in the FROM-clause:\n-- (natural) join:\nR1 NATURAL JOIN R2\n-- equijoin:\nR1 JOIN R2 ON R1.A1 = R2.B1\nAND ...\nAND R1.Ak = R2.Bk\n-- Θ-joins generalise equijoins by allowing inequations in the:\nON <clause>"}},"/ex01-ds-type":{"title":"数据库类型","data":{"oracle#Oracle":"支持众多 OS\n能存储、定义、操作大量数据\n分布式 DBMS，支持各种分布功能，如 Web 数据库\n支持联机分析处理（OLAP）和数据仓库（DW）","microsoft-sql-server#Microsoft SQL Server":"为了解决 Windows 系统数据库缺陷，微软和 Sybase 合作，并于 1989 年推出了 SQL Server 1.0 版本。\n微软在 1990 年推出 DBMS，支持客户机/服务器。\n该数据系统也是高性能 DBMS，具有较高的性价比。","sybase#Sybase":"Sybase 公司成立于 1984 年，其名也是 “System” 和 “Database” 的结合。\n1987 年 Sybase 推出了 Sybase SQLServer 1.0。\nSybase 首先提出 Client/Server 数据库体系结构的思想，并率先在 Sybase SQLServer 中实现。","db2#DB2":"DB2 由 IBM 公司推出。\nDB2 for MVSV1 在年推出。该版本的目标是提供数据解决方案的简单性。","visual-foxpro#Visual FoxPro":"由 Fox 公司 1988 年推出，并在 1992 年被微软收购后还持续推出了 FoxPro 2.5 等版本。\nFoxPro 比 FoxBASE 在功能和稳定性上都有极大的提升。","access#Access":"由 Microsoft 公司于 1994 年推出，特点是界面友好，易学易用，简单灵活。\n作为 Office 的一部分，可于 Office 深度集成，无缝衔接。\n存储利用 Web 检索和发布数据，主要适用于中小型应用系统。","mysql#MySQL":"小型关系型数据库管理系统，开发者为 MySQL AB 公司，于 2008 年被 Sun 公司收购。\n主要用于网络数据库。官方网站为： www.mysql.com","oceanbase#OceanBase":"由蚂蚁集团推出的完全自主研发的国产原生分布式数据库，于 2010 年创立。\n使用一套引擎并同时支持 TP 和 AP 的混合负载，兼容 SQL 标准。\n具有数据强一致性、高可用、高性能、低成本特点。"}},"/experiment":{"title":"Experiment","data":{}},"/experiment/01-setup-mysql":{"title":"01 Basic Mysql, Create table, alter table","data":{"mysql-安装#MySQL 安装":"下载 MySQL：https://dev.mysql.com/downloads/mysql/\n安装 Workbench：https://dev.mysql.com/downloads/file/?id=492434（此链接非最新版，可以下载最新版）\nMySQL-mysql 安装教程：https://www.cnblogs.com/laumians-notes/p/9069498.html\n下载 Zip 安装包：MySQL8 For Windows zip，进入页面后可以不登录。后点击底部“No thanks, just start my download.”即可开始下载。\n解压 zip 包到安装目录；\n配置环境变量：\n配置初始化的 my.ini 文件我们发现解压后的目录并没有 my.ini 文件，没关系可以自行创建。在安装根目录下添加 my.ini（新建文本文件，将文件类型改为.ini），写入基本配置：\n[mysqld]\n# 设置3306端口\nport=3306\n# 设置mysql的安装目录\nbasedir=E:\\\\software\\\\mysql\\\\mysql-8.0.11-winx64 # 切记此处一定要用双斜杠\\\\，单斜杠我这里会出错，不过看别人的教程，有的是单斜杠。自己尝试吧\n# 设置mysql数据库的数据的存放目录\ndatadir=E:\\\\software\\\\mysql\\\\mysql-8.0.11-winx64\\\\Data # 此处同上\n# 允许最大连接数\nmax_connections=200\n# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统\nmax_connect_errors=10\n# 服务端使用的字符集默认为UTF8\ncharacter-set-server=utf8\n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine=INNODB\n# 默认使用“mysql_native_password”插件认证\ndefault_authentication_plugin=mysql_native_password\n[mysql]\n# 设置mysql客户端默认字符集\ndefault-character-set=utf8\n[client]\n# 设置mysql客户端连接服务端时默认使用的端口\nport=3306\ndefault-character-set=utf8\n安装 MySQL：在安装时，必须以管理员身份运行 cmd，否则在安装时会报错，会导致安装失败的情况。在 MySQL 安装目录的 bin 目录下执行命令：\nmysqld --initialize --console\n执行完成后，会打印 root 用户的初始默认密码，比如：\nC:\\Users\\Administrator>cd C:\\Program Files\\MySQL\\bin\nC:\\Program Files\\MySQL\\bin>mysqld --initialize --console\n2018-04-28T15:57:17.087519Z 0 [System] [MY-013169] [Server] C:\\Program Files\\MySQL\\bin\\mysqld.exe (mysqld 8.0.11) initializing of server in progress as process 4984\n2018-04-28T15:57:24.859249Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: rI5rvf5x5G,E\n2018-04-28T15:57:27.106660Z 0 [System] [MY-013170] [Server] C:\\Program Files\\MySQL\\bin\\mysqld.exe (mysqld 8.0.11) initializing of server has completed\n注意！执行输出结果里面有一段： [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: rI5rvf5x5G,E 其中 root@localhost:后面的“rI5rvf5x5G,E”就是初始密码（不含首位空格）。在没有更改密码前，需要记住这个密码，后续登录需要用到。要是你手贱，关快了，或者没记住，那也没事，删掉初始化的 datadir 目录，再执行一遍初始化命令，又会重新生成的。当然，也可以使用安全工具，强制改密码，用什么方法，自己随意。参考：https://dev.mysql.com/doc/refman/8.0/en/data-directory-initialization-mysqld.html\n安装 MySQL 服务在 MySQL 安装目录的 bin 目录下执行命令：\nmysqld --install [服务名]\n后面的服务名可以不写，默认的名字为 mysql。当然，如果你的电脑上需要安装多个 MySQL 服务，就可以用不同的名字区分了，比如 mysql5 和 mysql8。\n启动服务安装完成之后，就可以通过命令启动 MySQL 的服务：\nnet start mysql\n停止服务命令：\nnet stop mysql\n卸载 MySQL 服务：\nsc delete MySQL/mysqld -remove\n更改密码MySQL 安装目录的 bin 目录下执行命令：\nmysql -u root -p\n这时候会提示输入密码，记住了上面第 3.1 步安装时的密码，填入即可登录成功，进入 MySQL 命令模式。如果你不喜欢明文密码，你可以尝试：\nmysql -uroot -p\n这时候会提示输入密码，记住了上面第 5 步安装时的密码，填入即可登录成功，进入 MySQL 命令模式。在 MySQL 中执行命令：\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '新密码';\n到此，安装部署就完成了。可以用命令查看一下默认安装的数据库：\nshow databases;\nuse mysql;\nshow tables;\nmysql> show databases;\n+--------------------+\n| Database           |\n+--------------------+\n| information_schema |\n| mysql              |\n| performance_schema |\n| sys                |\n+--------------------+\n4 rows in set (0.01 sec)\nmysql>\n看到默认初始化了 mysql 数据库，其中 user 表里面存储 MySQL 用户信息。我们可以看一下默认 MySQL 用户：\nselect user,host,authentication_string from mysql.user;\nmysql> select user,host,authentication_string from mysql.user;\n+------------------+-----------+-------------------------------------------+\n| user             | host      | authentication_string                     |\n+------------------+-----------+-------------------------------------------+\n| mysql.infoschema | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |\n| mysql.session    | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |\n| mysql.sys        | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |\n| root             | localhost | *27C237A977F4F44D3F551F1A673BE14DFD232961 |\n+------------------+-----------+-------------------------------------------+\n4 rows in set (0.00 sec)\nmysql>\n管理员 root 的 host 是 localhost，代表仅限 localhost 登录访问。如果要允许开放其他 ip 登录，则需要添加新的 host。如果要允许所有 ip 访问，可以直接修改成“%”。创建用户：\nCREATE USER 'xxh'@'%' IDENTIFIED WITH mysql_native_password BY 'xxh123!@#';\nmysql> use mysql;\nDatabase changed\nmysql> CREATE USER 'xxh'@'%' IDENTIFIED WITH mysql_native_password BY 'xxh123!@#'; #创建用户(注意：mysql8.0加密方式修改了)\nQuery OK, 0 rows affected (0.07 sec)\n检查用户：\nselect user, host, plugin, authentication_string from user\\G;\nmysql> select user, host, plugin, authentication_string from user;\n+------------------+-----------+-----------------------+-------------------------------------------+\n| user             | host      | plugin                | authentication_string                     |\n+------------------+-----------+-----------------------+-------------------------------------------+\n| xxh              | %         | mysql_native_password | *70FD6FB4F675E08FF785A754755B5EBA6DA62851 |\n| mysql.infoschema | localhost | mysql_native_password | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |\n| mysql.session    | localhost | mysql_native_password | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |\n| mysql.sys        | localhost | mysql_native_password | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |\n| root             | localhost | mysql_native_password | *27C237A977F4F44D3F551F1A673BE14DFD232961 |\n+------------------+-----------+-----------------------+-------------------------------------------+\n5 rows in set (0.00 sec)\nmysql>\n授权远程数据库：\n# 授权所有权限\nGRANT ALL PRIVILEGES ON *.* TO 'xxh'@'%'；\n# 授权基本的查询修改权限，按需求设置\nGRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON *.* TO 'xxh'@'%';\n查看用户权限：\nshow grants for 'xxh'@'%';\n另外，如果需要新增账户，或者本机以外的其他人访问 MySQL 则还需要设置内置账户的 host，具体可以参考：MySQL 创建用户与授权","mysql-存储引擎#MySQL 存储引擎":"MySQL 中的数据用各种不同的技术存储在文件(或者内存)中。不同的存储机制、索引技巧、锁定水平：选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。例如，研究大量临时数据，使用内存 MySQL 存储引擎较好。内存存储引擎能够在内存中存储所有的表格数据。或者需要一个支持事务处理的数据库(以确保事务处理不成功时数据的回退能力)。不同的技术以及配套的相关功能在 MySQL 中被称作存储引擎(也称作表类型)。","mysql-常用的四种引擎的介绍#MySQL 常用的四种引擎的介绍":"MyISAM 存储引擎\n优点：访问速度快，对事务完整性没有要求。支持全文搜索。表格可以被压缩。\n缺点：不支持事务（回滚将造成不完全回滚，不具有原子性）、也不支持外键。跨平台很难直接拷贝。\n适用：以 select，insert 为主的应用基本上可以用这个引擎来创建。\n操作上：DELETE 表时，先 drop 表，然后重建表。保存表的具体行数，不带 where 时，直接返回保存的行数。MyISAM 中可以使 AUTO_INCREMENT 类型字段建立联合索引。\n存放上：MyISAM 表被存放在三个文件 。frm 文件存放表格定义。数据文件是 MYD (MYData) 。索引文件是 MYI (MYIndex)。\nInnoDBInnoDB 是一个健壮的事务型存储引擎，这种存储引擎已经被很多互联网公司使用，为用户操作非常大的数据存储提供了一个强大的解决方案。\n优点：支持事务处理；不加锁读取；支持外键；支持行锁。跨平台可直接拷贝使用。\n缺点：不支持 FULLTEXT 类型的索引；不保存表的具体行数，扫描表来计算有多少行。表格很难被压缩。\n操作上：DELETE 表时，是一行一行的删除。InnoDB 中必须包含 AUTO_INCREMENT 类型字段的索引。\n存放上：InnoDB 把数据和索引存放在表空间里面。\n因为 MyISAM 相对简单，所以在效率上要优于 InnoDB。如果系统读多写少，对原子性要求低，那么 MyISAM 最好的选择。且 MyISAM 恢复速度快，可直接用备份覆盖恢复。如果系统读少，写多的时候，尤其是并发写入高的时候，InnoDB 就是首选了。\nMEMORY 存储引擎Memory 存储引擎使用存在于内存中的内容来创建表。每个 memory 表只实际对应一个磁盘文件，格式是.frm。memory 类型的表访问非常的快，因为它的数据是放在内存中的，并且默认使用 HASH 索引，但是一旦服务关闭，表中的数据就会丢失掉。MEMORY 存储引擎的表可以选择使用 BTREE 索引或者 HASH 索引，两种不同类型的索引有其不同的使用范围。如：\ncreate table users (\n    id smallint unsigned not null auto_increment,\n    username varchar(15) not null,\n    pwd varchar(15) not null,\n    index using btree (username),\n    primary key (id)\n) engine=memory;\nMERGE 存储引擎Merge 存储引擎是一组 MyISAM 表的组合，这些 MyISAM 表必须结构完全相同，merge 表本身并没有数据，对 merge 类型的表可以进行查询，更新，删除操作，这些操作实际上是对内部的 MyISAM 表进行的。","如何选择存储引擎#如何选择存储引擎":"InnoDB：用于事务处理；并发控制；需要频繁更新、删除操作（默认存储引擎）\nMyISAM：管理非事务表，高速存储和检索，全文检索；插入数据快，空间和内存使用比较低。插入新纪录和读出记录，效率高；\nMemory：所有数据都在内存中，数据处理速度快，但安全性不高。对表大小有要求，不能建太大的表。","mysql-的一些细节#MySQL 的一些细节":"","关于大小写#关于大小写":"MySQL 默认是不区分大小写的，但是在很多情况下需要大小敏感，以下总结了多种设置 MySQL 大小写敏感的方法。修改 MySql Server 安装目录下的 my.ini 文件，在 mysqld 节下加入下面一行：\nset-variable=lower_case_table_names=0\n# 0：大小写敏感；1：大小写不敏感\n最后重启一下 MySQL 服务即可。","注释#注释":"单行注释：\n“#” + 注释。\n“--” + 空格 + 注释（空格不可省略）。\n多行注释：用 /**/ 包裹注释内容。","别名#别名":"部分操作名等价，如：\ncreate database stu_course;\n-- 等价于：\ncreate schema stu_course;","查看信息#查看信息":"-- 查看当前数据库内的所有表格\nShow tables;\n-- 查看使用引擎\nShow engines;\n-- 查看所有数据库\nShow databases;\n# 也可以写作 Show schemas;","执行脚本#执行脚本":"source E:/mysql_source_code/1_create_all.sql","创建表#创建表":"见：\nChapter3@示例\nChapter3@建\nChapter3@数据表中数据的操纵\n查看相关信息：\nShow columns from student # 查看表结构\nDescribe student;\nDescribe student sno;","实践#实践":"练习启动 mysql 服务；连接 mysql；创建数据库；创建表；更新表和删除表\n完成以自己”学号后三位_名字_book”命名的数据库的建立，如：003*王毅_book;\n分别使用 workbench 或 Navicat 图形用户界面方式和命令提示符方式完成下面五张表的建立。在实践中应包括所有类型的约束，例如唯一性，非空值，外键等。\n用 sql 语句练习表的修改和删除，学生应测试不同种类的表的修改。\n请学会尝试利用百度的方法解决遇到的问题。\n请将练习的内容截屏到实验报告中，文字说明操作的内容，遇到的问题，如何解决的。\n实验报告命名方式： 003--姓名--实验 1-2.doc。\n前两次实验 Lab1,Lab2 提交一次实验报告。自己做实验，不要抄袭他人截屏！\n全英文撰写实验报告。"}},"/experiment/03-constraints-and-indexing":{"title":"03 Data integrity constraints, the function of use, index creation","data":{"constraints-数据完整性约束#Constraints 数据完整性约束":"详见：Chapter3@定义数据表的约束\nPRIMARY KEY(PK)：标识该字段为该表的主键，可以唯一的标识记录\nFOREIGN KEY(FK)：标识该字段为该表的外键\nNOT NULL：标识该字段不能为空\nUNIQUE KEY(UK)：标识该字段的值是唯一的\nAUTO_INCREMENT：标识该字段的值自动增长（整数类型，而且为主键）\nDEFAULT：为该字段设置默认值","唯一约束-unique#唯一约束 UNIQUE":"方法一：\ncreate table department1(\n    id int,\n    name varchar(20) unique,\n    comment varchar(100)\n);\n方法二：\ncreate table department2(\n    id int,\n    name varchar(20),\n    comment varchar(100),\n    # 设置规则（constraint），名为 uk_name\n    constraint uk_name unique(name)\n);\n测试执行结果：\ninsert into department1 values(1,'IT','技术');\n# Query OK, 1 row affected (0.00 sec)\ninsert into department1 values(1,'IT','技术');\n# ERROR 1062 (23000): Duplicate entry 'IT' for key 'name'","not-null-与-default#not null 与 default":"如：\ncreate table student2(\n    id int primary key auto_increment,\n    name char(5),\n    sex enum('male','female') not null default 'female'\n);","auto_increment#auto_increment":"不指定 id，则自动增长。如：\n-- 假设我们有设计了这样一个表格：\ncreate table student(\n    id int primary key auto_increment,\n    name varchar(20),\n    sex enum('male','female') default 'male'\n);\n-- 这是它的各个列：\ndesc student;\n# +-------+-----------------------+------+-----+---------+----------------+\n# | Field | Type                  | Null | Key | Default | Extra          |\n# +-------+-----------------------+------+-----+---------+----------------+\n# | id    | int(11)               | NO   | PRI | NULL    | auto_increment |\n# | name  | varchar(20)           | YES  |     | NULL    |                |\n# | sex   | enum('male','female') | YES  |     | male    |                |\n# +-------+-----------------------+------+-----+---------+----------------+\n-- 试图不带 id 添加：\ninsert into student(name) values\n# -> ('egon'),\n# -> ('alex')\n-- 查看表格数据：\nselect * from student;\n# +----+------+------+\n# | id | name | sex  |\n# +----+------+------+\n# |  1 | egon | male |\n# |  2 | alex | male |\n# +----+------+------+","function-函数#Function 函数":"","1-数学函数#1. 数学函数":"ABS(x)：返回 x 的绝对值\nBIN(x)：返回 x 的二进制（OCT返回八进制，HEX返回十六进制）\nCEILING(x)：返回大于 x 的最小整数值\nEXP(x)：返回值 e（自然对数的底）的 x 次方\nFLOOR(x)：返回小于 x 的最大整数值\nGREATEST(x1,x2,...,xn)：返回集合中最大的值\nLEAST(x1,x2,...,xn)：返回集合中最小的值\nLN(x)：返回 x 的自然对数\nLOG(x,y)：返回 x 的以 y 为底的对数\nMOD(x,y)：返回 x/y 的模（余数）\nPI()：返回 pi 的值（圆周率）\nRAND()：返回０到１内的随机值，可以通过提供一个参数(种子)使RAND()随机数生成器生成一个指定的值。\nROUND(x,y)：返回参数 x 的四舍五入的有 y 位小数的值\nSIGN(x)：返回代表数字 x 的符号的值\nSQRT(x)：返回一个数的平方根\nTRUNCATE(x,y)：返回数字 x 截短为 y 位小数的结果","2-聚合函数#2. 聚合函数":"常用于 GROUP BY 从句的 SELECT 查询中。\nAVG(col)：返回指定列的平均值\nCOUNT(col)：返回指定列中非 NULL 值的个数\nMIN(col)：返回指定列的最小值\nMAX(col)：返回指定列的最大值\nSUM(col)：返回指定列的所有值之和\nGROUP_CONCAT(col)：返回由属于一组的列值连接组合而成的结果","3-字符串函数#3. 字符串函数":"ASCII(char)：返回字符的 ASCII 码值\nBIT_LENGTH(str)：返回字符串的比特长度\nCONCAT(s1,s2...,sn)：将 s1,s2...,sn 连接成字符串\nCONCAT_WS(sep,s1,s2...,sn)：将 s1,s2...,sn 连接成字符串，并用 sep 字符间隔\nINSERT(str,x,y,instr)：将字符串 str 从第 x 位置开始，y 个字符长的子串替换为字符串 instr，返回结果\nFIND_IN_SET(str,list)：分析逗号分隔的 list 列表，如果发现 str，返回 str 在 list 中的位置\nLCASE(str)或LOWER(str)：返回将字符串 str 中所有字符改变为小写后的结果\nLEFT(str,x)：返回字符串 str 中最左边的 x 个字符\nLENGTH(s)：返回字符串 str 中的字符数\nLTRIM(str)：从字符串 str 中切掉开头的空格\nPOSITION(substr,str)：返回子串substr在字符串str中第一次出现的位置\nQUOTE(str)：用反斜杠转义str中的单引号\nREPEAT(str,srchstr,rplcstr)：返回字符串str重复x次的结果\nREVERSE(str)：返回颠倒字符串str的结果\nRIGHT(str,x)：返回字符串str中最右边的x个字符\nRTRIM(str)：返回字符串str尾部的空格\nSTRCMP(s1,s2)：比较字符串s1和s2\nTRIM(str)：去除字符串首部和尾部的所有空格\nUCASE(str)或UPPER(str)：返回将字符串str中所有字符转变为大写后的结果","4-日期和时间函数#4. 日期和时间函数":"CURDATE()或CURRENT_DATE()：返回当前的日期\nCURTIME()或CURRENT_TIME()：返回当前的时间\nDATE_ADD(date,INTERVAL int keyword)：返回日期date加上间隔时间int的结果(int必须按照关键字进行格式化)，如：\nSELECT DATE_ADD(CURRENT_DATE, INTERVAL 6 MONTH);\nDATE_FORMAT(date,fmt)：依照指定的fmt格式格式化日期date值\nDATE_SUB(date,INTERVAL int keyword)：返回日期date减去间隔时间int的结果(int必须按照关键字进行格式化)，如：\nSELECT DATE_SUB(CURRENT_DATE, INTERVAL 6 MONTH);\nDAYOFWEEK(date)：返回date所代表的一星期中的第几天(1~7)注意是：1=星期天，2=星期一, …，7=星期六，这些索引值对应于 ODBC 标准。如：\nselect DAYOFWEEK('1998-02-03');\n# 3\nDAYOFMONTH(date)：返回date是一个月的第几天(1~31)\nDAYOFYEAR(date)：返回date是一年的第几天(1~366)\nDAYNAME(date)：返回date的星期名，如：\nSELECT DAYNAME(CURRENT_DATE);\nFROM_UNIXTIME(ts,fmt)：根据指定的fmt格式，格式化 UNIX 时间戳ts\nHOUR(time)：返回time的小时值(0~23)\nMINUTE(time)：返回time的分钟值(0~59)\nMONTH(date)：返回date的月份值(1~12)\nMONTHNAME(date)：返回date的月份名，如：SELECT MONTHNAME(CURRENT_DATE);\nNOW()：返回当前的日期和时间\nQUARTER(date)：返回date在一年中的季度(1~4)，如SELECT QUARTER(CURRENT_DATE);\nWEEK(date)：返回日期date为一年中第几周(0~53)\nYEAR(date)：返回日期date的年份(1000~9999)W\n额外的几个日期处理函数：","date_formatdateformat#DATE_FORMAT(date,format)":"根据 format 字符串格式化 date 值。下列修饰符可以被用在 format 字符串中：\n%M：月名字（January ~ December）\n%W：星期名字（Sunday ~ Saturday）\n%D：有英语前缀的月份的日期（1st，2nd，3rd，等等。）\n%Y：年，数字，4 位\n%y：年，数字，2 位\n%a：缩写的星期名字（Sun ~ Sat）\n%d：月份中的天数，数字（00 ~ 31）\n%e：月份中的天数，数字（0 ~ 31）\n%m：月，数字（01 ~ 12）\n%c：月，数字（1 ~ 12）\n%b：缩写的月份名字（Jan ~ Dec）\n%j：一年中的天数（001 ~ 366）\n%H：小时（00 ~ 23）\n%k：小时（0 ~ 23）\n%h：小时（01 ~ 12）\n%I：小时（01 ~ 12）\n%l：小时（1 ~ 12）\n%i：分钟，数字（00 ~ 59）\n%r：时间,12 小时（hh:mm:ss [AP]M）\n%T：时间,24 小时（hh:mm:ss）\n%S：秒（00 ~ 59）\n%s：秒（00 ~ 59）\n%p：AM 或 PM\n%w：一个星期中的天数（0=Sunday ~ 6=Saturday\n%U：星期（0 ~ 52），这里星期天是星期的第一天\n%u：星期（0 ~ 52），这里星期一是星期的第一天\n%%：一个文字“%”。\n如：\nselect DATE_FORMAT('1997-10-04 22:23:00', '%W %M %Y');\n# 'Saturday October 1997'\nselect DATE_FORMAT('1997-10-04 22:23:00', '%H:%i:%s');\n# '22:23:00'\nselect DATE_FORMAT('1997-10-04 22:23:00',\n'%D %y %a %d %m %b %j');\n# '4th 97 Sat 04 10 Oct 277'\nselect DATE_FORMAT('1997-10-04 22:23:00',\n'%H %k %I %r %T %S %w');\n# '22 22 10 10:23:00 PM 22:23:00 00 6'\n注：MySQL 3.23 中，在格式修饰符字符前需要%。在 MySQL 更早的版本中，%是可选的。","to_days-和-from_days#to_days() 和 from_days()":"TO_DAYS(date) 给出一个日期 date，返回一个天数(从 0 年开始的天数)。如：\nSELECT TO_DAYS(950501);\n# 728779\nSELECT TO_DAYS('1997-10-07');\n# 729669\nFROM_DAYS(N) 给出一个天数 N，返回一个 DATE 值。如：\nSELECT FROM_DAYS(729669);\n# '1997-10-07'\n结合：\n-- 选择某列中 date_col 的值是在最后30天以内：\nSELECT something FROM table\nWHERE TO_DAYS(NOW()) - TO_DAYS(date_col) <= 30;\n如：\n-- 获取当前系统时间：\nSELECT EXTRACT(YEAR_MONTH FROM CURRENT_DATE);\nSELECT EXTRACT(DAY_SECOND FROM CURRENT_DATE);\nSELECT EXTRACT(HOUR_MINUTE FROM CURRENT_DATE);\n-- 返回两个日期值之间的差值(月数)：\nSELECT PERIOD_DIFF(200302,199802);","5-加密函数#5. 加密函数":"以下是文段的 markdown 格式：\nAES_ENCRYPT(str,key)：返回用密钥 key 对字符串 str 利用高级加密标准算法加密后的结果，调用 AES_ENCRYPT 的结果是一个二进制字符串，以 BLOB 类型存储\nAES_DECRYPT(str,key)：返回用密钥 key 对字符串 str 利用高级加密标准算法解密后的结果\nDECODE(str,key)：使用 key 作为密钥解密加密字符串 str\nENCRYPT(str,salt)：使用UNIXcrypt()函数，用关键词 salt(一个可以惟一确定口令的字符串，就像钥匙一样)加密字符串 str\nENCODE(str,key)：使用 key 作为密钥加密字符串 str，调用 ENCODE()的结果是一个二进制字符串，它以 BLOB 类型存储\nMD5()：计算字符串 str 的 MD5 校验和\nPASSWORD(str)：返回字符串 str 的加密版本，这个加密过程是不可逆转的，和 UNIX 密码加密过程使用不同的算法。从原文密码 str 计算并返回密码字符串，当参数为 NULL 时返回 NULL。这个函数用于用户授权表的 Password 列中的加密 MySQL 密码存储\nSHA()：计算字符串 str 的安全散列算法(SHA)校验和\n如：\nSELECT ENCRYPT('root','salt');\nSELECT ENCODE('xufeng','key');\nSELECT DECODE(ENCODE('xufeng','key'),'key'); # 加解密放在一起\nSELECT AES_ENCRYPT('root','key');\nSELECT AES_DECRYPT(AES_ENCRYPT('root','key'),'key');\nSELECT MD5('123456');\nSELECT SHA('123456');","8-类型转化函数#8. 类型转化函数":"为了进行数据类型转化，MySQL 提供了 CAST() 函数，它可以把一个值转化为指定的数据类型。类型包括：BINARY,CHAR,DATE,TIME,DATETIME,SIGNED,UNSIGNED\n如：\nSELECT CAST(NOW() AS SIGNED INTEGER), CURDATE() + 0;\n# 20230426074051 20230426\nSELECT 'f' = BINARY 'F','f' = CAST('F' AS BINARY);\n# 0 0\n或者也可以直接使用转化函数：\nselect ASCII('2');\n# 50\nselect ASCII(2);\n# 50\nselect ASCII('dx');\n# 100\nselect CHAR(77,121,83,81,'76');\n# 'MySQL'\n# select CHAR(77,77.3,'77.3');\n'MMM‘","9-系统信息函数#9. 系统信息函数":"DATABASE()：返回当前数据库名。\nBENCHMARK(count,expr)：将表达式expr重复运行count次。这个函数通常用于测试查询或计算的性能。\nCONNECTION_ID()：返回当前客户端的连接 ID。\nFOUND_ROWS()：返回最近一个SELECT查询检索的总行数，用于在使用LIMIT语句时确定实际返回的行数。\nUSER() 或 SYSTEM_USER()：返回当前登录用户的用户名。\nVERSION()：返回 MySQL 服务器的版本。\n如：\n-- 返回当前数据库名、MySQL服务器版本和当前登录用户名\nSELECT DATABASE(), VERSION(), USER();\n-- 运行一个表达式9999999次，并显示所需的时间。\nSELECT BENCHMARK( 9999999, LOG(RAND() * PI()) );","index-索引#Index 索引":"详见：Chapter3@创建与使用索引\n直接添加索引：\nCREATE INDEX indexName ON mytable(username(length));\n如果是 CHAR，VARCHAR 类型，length 可以小于字段实际长度；如果是 BLOB 和 TEXT 类型，必须指定 length。\n通过修改表结构添加索引：\nALTER table tableName ADD INDEX indexName(columnName)\n创建表的时候直接指定：\nCREATE TABLE mytable(\n    ID INT NOT NULL,\n    username VARCHAR(16) NOT NULL,\n    INDEX [indexName] (username(length))\n);"}},"/experiment/02-select-create-view":{"title":"02 Practicing Select and Creating view","data":{"select-语句#Select 语句":"","连接-join#连接 JOIN":"详见：Chapter3@多关系（表）的连接查询在不使用 on 语法时，join、inner join、逗号、cross join 结果相同，都是取 2 个表的笛卡尔积。on 语法：筛选连接后的结果，两表的对应列值相同才在结果集中，可以通过 and 连接多个列值的匹配要求，列名可以不同。如：\nselect * from tb_test1\ninner join tb_student\non tb_test1.id=tb_student.id;\n用 on 自然连接：using 语法：筛选连接后的结果，两表的对应列值相同才在结果集中，括号内用多个列名要求用逗号连接，列名必须相同。如：\nselect * from tb_test1\ncross join tb_student\nusing(id);\n用 using 连接更简洁一些：连接关键字：\nINNER JOIN（内连接或等值连接）：获取两个表中字段匹配关系的记录。\nLEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。\nRIGHT JOIN（右连接）：与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。\n全连接：MySQL 没有全外连接，用 union 将左右外连接合并。\n如果我们有一个包含名字和姓氏的表格，可以使用 CONCAT 函数将这两个字段连接起来形成一个完整的姓名字段。在 MySQL 中，使用 CONCAT 函数的语法如下：\nSELECT CONCAT(first_name, ' ', last_name) AS full_name\n# 有时也写成 SELECT CONCAT(last_name,', ',first_name) AS full_name\nFROM table_name;\n这条语句将会返回一个名为 full_name 的新字段，其中包含了名字和姓氏的组合。","分组-group-by#分组 GROUP BY":"详见：Chapter3@分组查询细化聚集函数的作用对象：\n未对查询结果分组，聚集函数将作用于整个查询结果\n对查询结果分组后，聚集函数将分别作用于每个组\n作用对象是查询的中间结果表\n按指定的一列或多列值分组，值相等的为一组\n如：求各个课程号及相应的选课人数。\nSELECT Cno，COUNT(Sno) FROM SC\nGROUP BY Cno;\nCno\tCOUNT(Sno)\t1\t22\t2\t34\t​ 3\t44\t4\t33\t​ 5\t48\t\nHAVING 短语与 WHERE 子句的区别：\n作用对象不同\nWHERE 子句作用于基表或视图，从中选择满足条件的元组\nHAVING 短语作用于组，从中选择满足条件的组。","动态-sql-语句#动态 SQL 语句":"动态 SQL 语句是一种在运行时构建的 SQL 语句，其结构和内容取决于程序的执行过程中的变量和条件。相比于静态 SQL 语句，动态 SQL 语句更灵活，可以根据实际情况生成不同的 SQL 语句，从而满足不同的查询需求。在动态 SQL 语句中，可以使用变量、参数、条件和运算符等元素，通过这些元素可以构建出完整的 SQL 语句。通常情况下，动态 SQL 语句会由程序自动生成，然后将其发送到数据库进行解析和执行。动态 SQL 语句的优点在于可以根据不同的条件生成不同的 SQL 语句，从而提高查询效率并且减少代码复杂性。但是，需要注意的是，在使用动态 SQL 语句时，应该避免SQL 注入等安全问题。因此，在构建动态 SQL 语句时，应该使用参数化查询来代替字符串拼接，以避免潜在的安全风险。如：\n-- For prepared statements, you can use placeholders. The following statements will return one row from the tbl table:\nSET @a=1; # 将一个变量@a赋值为1，这里是为了在后面的语句中使用变量@a作为参数。\nPREPARE STMT\nFROM 'SELECT * FROM student LIMIT ?';\nEXECUTE STMT USING @a;\n-- The following statements will return the second to sixth row from the tbl table:\nSET @skip=1;\nSET @numrows=5;\nPREPARE STMT\nFROM 'SELECT * FROM tbl LIMIT ?, ?';\nEXECUTE STMT\nUSING @skip, @numrows;","视图-view#视图 VIEW":"详见：Chapter3@视图视图（View）是一种虚拟存在的表。其内容与真实的表相似，包含一系列带有名称的列和行数据。但是视图并不在数据库中以存储的数据的形式存在。行和列的数据来自定义视图时查询所引用的基本表，并且在具体引用视图时动态生成。\n视图的特点如下：1.  视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系；\n2.  视图是由基本表（实表）产生的表（虚表）；\n3.  视图的建立和删除不影响基本表；\n4.  对视图内容的更新（增删改）直接影响基本表；\n5.  当视图来自多个基本表时，不允许添加和删除数据。CREATE VIEW 语句创建一个新的视图，或者如果添加了 OR REPLACE 子句，则替换现有的视图。如果该视图不存在，则 CREATE OR REPLACE VIEW 与 CREATE VIEW 相同。如果该视图存在，则 CREATE OR REPLACE VIEW 将其替换。可以使用 WITH CHECK OPTION 子句来限制对视图引用的表中行的插入或更新。这意味着只有符合限制条件的数据可以被插入或更新到视图中。如：我们有一个名为 student 的表，其中包含学生的成绩和课程信息。我们可以创建一个视图，只显示英语课程的成绩，并使用 WITH CHECK OPTION 子句来限制只能插入或更新英语课程的成绩数据。这样，我们就可以确保只有符合条件的数据才会出现在视图中。\nCREATE VIEW english_grades AS\nSELECT student_name, grade\nFROM student\nWHERE course = 'English'\nWITH CHECK OPTION;\n这个视图只包含英语课程的成绩，而且当试图插入或更新不符合条件的数据时，会抛出错误。例如，如果我们尝试将数学课程的成绩插入到该视图中，就会收到一条错误消息：\nINSERT INTO english_grades (student_name, grade)\nVALUES ('Alice', 'B');\n-- Error: new row violates check option for view \"english_grades\"\n但如果我们尝试将英语课程的成绩插入到该视图中，则不会收到任何错误消息：\nINSERT INTO english_grades (student_name, grade)\nVALUES ('Bob', 'A');\n-- 1 row inserted\nSQL 视图的限制：\n不支持使用 ORDER BY 子句对视图进行排序，除非使用 TOP 或者 LIMIT 等限制语句。\n不能在视图中使用临时表或表变量。\n视图不支持插入、更新或删除操作，除非使用 INSTEAD OF 触发器来代替这些操作。\n视图中不能包含任何计算字段或聚合函数，例如 SUM 和 AVG。\n如果视图定义中包含联接操作，则该视图可能会变得很复杂，并且查询速度可能会受到影响。\n视图可以引用其他视图，但是如果一个视图引用了另一个视图，那么查询语句的性能可能会受到影响。\n视图的性能可能会受到数据库中数据量的影响。当数据量很大时，查询视图可能会变得很慢。\n视图的权限必须正确配置，以确保只有授权用户才能访问视图中的数据。","insert-update-delete#Insert, Update, Delete":"详见：\nChapter3@建\nChapter3@数据表中数据的操纵","insert#Insert":"SQL 中的 INSERT 语句是用于向表中插入新行数据的命令。它可以将一条或多条记录插入到指定的表中，每个记录都由一个值列表表示。INSERT 语句的语法如下：\nINSERT INTO table_name (column1, column2, column3,...)\nVALUES (value1, value2, value3,...);\n其中，table_name是要插入数据的目标表名；(column1, column2, column3,...) 是要插入的列的名称列表； (value1, value2, value3,...) 是插入到相应列中的值列表。例如，如果我们有一个名为students的表，其中包含id, name, age, gender四列，我们可以使用以下 INSERT 语句向表中插入一条新的学生记录：\nINSERT INTO students (id, name, age, gender)\nVALUES (1, '张三', 18, '男');\n这个 INSERT 语句将在students表中插入一条id=1, name='张三', age=18, gender='男'的新记录。如果我们想插入多条记录，只需要在 VALUES 后面提供多组值即可。除了 VALUES 子句之外，还可以使用 SELECT 语句作为 INSERT 语句的数据来源，例如：\nINSERT INTO students (id, name, age, gender)\nSELECT id, name, age, gender FROM new_students;\n此语句将从new_students表中选择所有行，并将其插入到students表中。","update#Update":"SQL 中的 UPDATE 语句用于修改表中现有行的数据。使用 UPDATE 语句，可以更新一个或多个列的值，并且可以根据指定的条件来更新表中的特定行。UPDATE 语句的基本语法如下：\nUPDATE table_name\nSET column1 = value1, column2 = value2, ...\nWHERE condition;\n其中，table_name是要更新数据的目标表名；column1 = value1, column2 = value2,...是要更新的列和它们对应的新值列表；WHERE condition是一个可选的条件，满足该条件的行才会被更新。例如，假设我们有一个名为students的表，其中包含id, name, age, gender四列，我们可以使用以下 UPDATE 语句将某个学生的年龄从 18 修改为 20:\nUPDATE students\nSET age = 20\nWHERE id = 1;\n此语句将在students表中找到id=1的行，并将其age列的值更新为 20。除了单独更新某一行的数据之外，还可以使用 UPDATE 语句批量更新符合某个条件的所有行，例如：\nUPDATE students\nSET gender = '女'\nWHERE age > 20;\n此语句将在students表中找到所有age > 20的行，并将它们的gender列的值都更新为'女'。总之，UPDATE 语句可以帮助我们轻松地修改表中的现有数据，以便满足我们的需求。","delete#Delete":"SQL 中的 DELETE 语句用于从表中删除现有行。使用 DELETE 语句，可以删除特定行或满足特定条件的多行数据。DELETE 语句的基本语法如下：\nDELETE FROM table_name\nWHERE condition;\n其中，table_name是要删除数据的目标表名；WHERE condition是一个可选的条件，满足该条件的行才会被删除。例如，假设我们有一个名为students的表，其中包含id, name, age, gender四列，我们可以使用以下 DELETE 语句删除某个学生的记录：\nDELETE FROM students\nWHERE id = 1;\n此语句将在students表中找到id=1的行，并将其从表中删除。除了单独删除某一行之外，还可以使用 DELETE 语句批量删除符合某个条件的所有行，例如：\nDELETE FROM students\nWHERE age > 20;\n此语句将在students表中找到所有age > 20的行，并将它们从表中删除。\nDELETE 和 TRUNCATE 都可以用于删除表中的数据，但它们的实现方式和使用方法略有不同。DELETE 语句用于从表中删除特定行或满足特定条件的多行数据。它在执行时会逐行扫描表，并删除匹配条件的所有行，因此对于大型表而言，DELETE 语句可能会比较慢。TRUNCATE 语句用于快速删除整个表中的数据，它直接删除数据文件，然后重建一个空表。相比之下，TRUNCATE 语句执行速度更快，尤其是在处理大型表时。但需要注意的是，TRUNCATE 语句无法带有 WHERE 子句指定条件过滤，它总是删除整张表的数据。除了速度方面的不同，DELETE 和 TRUNCATE 还有一些其他区别：\nDELETE 语句执行后可以回滚，即在事务中执行 DELETE 语句后，如果回滚事务，则删除的数据会被恢复。而 TRUNCATE 语句执行后无法回滚。\nDELETE 语句执行后会保留自增长列和标识列的当前值，而 TRUNCATE 语句则会将这些值重置为初始值。\nDELETE 语句在执行时会触发表上的触发器（如 DELETE 触发器），而 TRUNCATE 语句不会触发任何触发器。\n在实际使用中，我们需要根据具体的情况选择 DELETE 或 TRUNCATE 语句。如果只需要删除表中的一部分数据，并且需要执行回滚操作，则应该使用 DELETE 语句；如果需要快速删除整张表的数据，并且不需要执行回滚操作，则可以考虑使用 TRUNCATE 语句。","实践#实践":"用 SQL 语句完成图书管理系统 book 数据库相关数据录入，同时使用相关语句进行：\n新表中插入数据（使用 into 子句）\n从某表中查询结果，分组，排序（使用 select from，where，group by，having，order by 子句）\n对数据库进行联合查询（使用 Union 子句）\n进行多表查询（等值、不等值，自然，外连接，自连接等）\n进行子查询（in，exists，having 中使用）\n创建视图\n针对 movies 数据库，做 lab1.pdf，lab2.pdf 上面的练习。要求：实验报告中除文字描述外，必须提供每一操作对应的 SQL 语句 word 文档，并附上执行结果截图。额外实验内容：\n用 SQL 语句完成图书管理系统 book 数据库相关数据录入，同时使用 insert，update, delete 语句对 book 数据库进行操作。\n每个语句至少练习 5 个以上的示例，请写出对应 SQL 语句所表达的意思。\n实验报告中除文字描述外，必须提供每一操作对应的 SQL 语句文本文档，并附上执行结果截图。列出实验中所遇到的问题，及如何解决问题的。"}},"/experiment/04-procedure-function-cursor":{"title":"04 Procedure, Function and Cursor","data":{"stored-program#Stored program":"Four types stored programs\nType\tDescription\tStored procedure\tCan be called from an application that has access to the database.\tStored function\tCan be called from a SQL statement. A stored function works much like the functions provided by MySQL that are described in chapter 9.\tTrigger\tIs executed in response to an INSERT, UPDATE, or DELETE statement on a specified table.\tEvent\tIs executed at a scheduled time.\t\n一个存储过程可以从应用程序调用，访问数据库存储函数可以调用从一个 SQL 语句，就像 MySQL 所提供的功能，不需要被称为触发器和事件。相反，他们发生时自动执行。\nWhy Use Stored Programs?\nThe use of stored programs can lead to a more secure database 使用存储程序可以获得更安全的数据库\nStored programs can reduce network traffic\nStored programs offer a mechanism to abstract data access routines, which can improve the maintainability of your code as underlying data structures evolve 存储程序提供了一种抽象数据访问例程的机制，可以随着底层数据结构的发展提高代码的可维护性","存储过程#存储过程":"存储过程是数据库的一个重要的功能。MySQL 5.0 开始支持存储过程，这样即可以大大提高数据库的处理速度，同时也可以提高数据库编程的灵活性。\nSQL 语句需要先编译然后执行。\n存储过程（Stored Procedure）是一组为了完成特定功能的 SQL 语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。存储过程是可编程的函数，在数据库中创建并保存，可以由 SQL 语句和控制结构组成。当想要在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。数据库中的存储过程可以看做是对编程中面向对象方法的模拟，它允许控制数据的访问方式。存储过程的优点：\n增强 SQL 语言的功能和灵活性：存储过程可以用控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。\n标准组件式编程：存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的 SQL 语句。而且数据库专业人员可以随时对存储过程进行修改，对应用程序源代码毫无影响。\n较快的执行速度：如果某一操作包含大量的 Transaction-SQL 代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的 Transaction-SQL 语句在每次运行时都要进行编译和优化，速度相对要慢一些。\n减少网络流量：针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的 Transaction-SQL 语句被组织进存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大减少网络流量并降低了网络负载。\n作为一种安全机制来充分利用：通过对执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。","存储函数#存储函数":"存储函数只能返回单个值。\n可以从 SQL 语句调用一个存储的函数\n存储的函数只有一种类型的参数，即 IN。但是可以设置默认值","syntax-of-mysql-stored-procedure#Syntax of MySQL Stored Procedure":"DELIMITER &&\nCREATE PROCEDURE procedure_name\n[[IN|OUT|INOUT] parameter_name datatype [parameter]]\nBEGIN \n\t-- statements \nEND &&\nDELIMITER;\n如：\n-- Change statement delimiter from semicolon to double front slash\nDELIMITER //\nCREATE PROCEDURE test()\nBEGIN\n\tDECLARE sum balancedue_var DECIMAL(9,2);\n    SELECT SUM(invoice_total payment_total-credit_total)\n\tINTO sum_balance_due_var\n\tFROM invoices\n\tWHERE vendor id 95;\n    IF sum_balance_due_var 0 THEN\n\t    SELECT CONCAT('Balance due: $'sum_balance_due_var) As message;\n\tELSE\n\t    SELECT 'Balance paid in full' As message;\n\tEND IF;\nEND//\n-- Change statement delimiter from double front slash to semicolon\nDELIMITER;\n-- 以后只需要这样调用即可\nCALL test();\n分隔符MySQL 默认以“;”为分隔符，如果没有声明分隔符，则编译器会把存储过程当成 SQL 语句进行处理，因此编译过程会报错，所以要事先用“DELIMITER //”声明当前段分隔符，//替代分号成为新的分隔符；让编译器把两个\"//\"之间的内容当做存储过程的代码，不会执行这些代码；后续代码也可用//作为分隔符。“DELIMITER;”的意为把分隔符还原为分号。\nA SQL statement used within stored programs:\nSELECT: Returns a result set to the calling program. Or, retrieves data from the database and stores it so it can be processed by the stored program.\n如：\nDELIMITER //\nCREATE PROCEDURE test ()\nBEGIN\n\tSELECT 'This is a test.' AS message;\nEND//","mysql-存储过程的创建#MySQL 存储过程的创建":"语法：\nCREATE PROCEDURE 过程名([[IN|OUT|INOUT] 参数名 数据类型[,[IN|OUT|INOUT] 参数名 数据类型…]]) [特性 ...] 过程体\n如：\nDELIMITER //\n  CREATE PROCEDURE myproc(OUT s int)\n    BEGIN\n      SELECT COUNT(*) INTO s FROM students;\n    END//\nDELIMITER;\n存储过程根据需要可能会有输入、输出、输入输出参数，如果有多个参数用\",\"分割开。MySQL 存储过程的参数用在存储过程的定义，共有三种参数类型，分别为 IN，OUT 和 INOUT：\nIN：参数的值必须在调用存储过程时指定，在存储过程中修改该参数的值不能被返回，为默认值\nOUT：该值可在存储过程内部被改变，并可返回\nINOUT：调用时指定，并且可被改变和返回\n过程体的开始与结束使用 BEGIN 与 END 进行标识。如：\nDELIMITER //\nCREATE PROCEDURE in_param(IN p_in INT) # 此处使用了参数类型\n    BEGIN\n    SELECT p_in;\n    SET p_in=2;\n    SELECT p_in;\nEND;\n//\nDELIMITER;\n# 调用\nSET @p_in=1;\nCALL in_param(@p_in);\nSELECT @p_in;\n-- 参数类型为 IN 时输出：1、2、1（p_in虽然在存储过程中被修改，但并不影响@p_id的值）\n-- 参数类型为 OUT 时输出：NULL、2、2（只要是 OUT 类型，存储过程内最初一定是 NULL）\n-- 参数类型为 INOUT 时输出：1、2、2（类比 C++ 中的引用传参）","mysql-存储过程的删除#MySQL 存储过程的删除":"DROP PROCEDURE [过程1[,过程2…]]\n从 MySQL 的表格中删除一个或多个存储过程。","sql-statements#SQL statements":"for controlling the flow of execution.","ifelseifelse#IF...ELSEIF...ELSE":"Controls the flow of execution based on a condition.类比 C++的 if...else if...else...。详细用法：\nIF boolean_expression THEN\n\tstatement_1;\n\t[statement 2;]...\n[ELSEIF boolean_expression THEN\n\tstatement_1;\n\t[statement_2;]...]...\n[ELSE\n\tstatement_1;\n\t[statement_2;]...]...\nEND IF;\n如：\nCREATE PROCEDURE test()\nBEGIN\n\tDECLARE first_invoice_due_date DATE;\n\tSELECT MIN(invoice_due_date)\n\tINTo first_invoice_due_date\n\tFROM invoices\n\tWHERE invoice_total - payment_total - credit_total > 0;\n\tIF first_invoice_due_date < NOW() THEN\n\t\tSELECT 'Outstanding invoices overdue!';\n\tELSEIF first_invoice_due_date = NOW() THEN\n\t\tSELECT 'Outstanding invoices are due today!';\n\tELSE\n\t\tSELECT'No invoices are overdue.';\n\tEND IF;\nEND//","casewhenelse#CASE...WHEN...ELSE":"Controls the flow of execution based on a condition.类比 C++的 switch...case x:...。详细用法：\nCASE expression\n\tWHEN expression_value_1 THEN\n\t\tstatement_1;\n\t\t[statement_2;]...\n\t[WHEN expression_value_2 THEN\n\t\tstatement1;\n\t\t[statement_2;]...]...\n\t[ELSE\n\t\tstatement_1;\n\t\t[statement_2;]...]...\nEND CASE;\n如：\nCREATE PROCEDURE test()\nBEGIN\n\tDECLARE terms_id_var INT;\n\tSELECT terms_id INTO terms_id_var\n\tFROM invoices WHERE invoice_id = 4;\n\tCASE terms_id_var\n\t\tWHEN 1 THEN\n\t\t\tSELECT 'Net due 10 days'As Terms;\n\t\tWHEN 2 THEN\n\t\t\tSELECT 'Net due 20 days'AS Terms;\n\t\tWHEN 3 THEN\n\t\t\tSELECT 'Net due 30 days'AS Terms;\n\t\tELSE\n\t\t\tSELECT 'Net due more than 30 days'AS Terms;\n\tEND CASE;\nEND//","whiledoloop#WHILE...DO...LOOP":"Repeats statements while a condition is true.类比 C++的 while...。详细用法：\nWHILE boolean_expression DO\n\tstatement 1;\n\t[statement_2;]...\nEND WHILE;\n如：\nCREATE PROCEDURE test ()\nBEGIN\n\tDECLARE i INT DEFAULT 1;\n\tDECLARE S VARCHAR(400) DEFAULT '119';\n\tWHILE i < 4 DO\n\t\tSET S = CONCAT(s, 'i=', i, ',');\n\t\tSET i = i + 1;\n\tEND WHILE;\n\tSELECT S AS message;\nEND //","repeatuntilend-repeat#REPEAT...UNTIL...END REPEAT":"Repeats statements while a condition is true.类比 C++的 do...while...A REPEAT loop:\nREPEAT\n\tSET s = CONCAT(s, 'i=', i, ' | ');\n\tSET i = i + 1;\nUNTIL i = 4\nEND REPEAT;\nA simple loop:\ntestLoop : LOOP\n\tSET s = CONCAT(s, 'i=', i, ' | ')\n\tSET i = i + 1;\n\tIF i = 4 THEN\n\t\tLEAVE testLoop;\n\tEND IF;\nEND LOOP testLoop;","declare-cursor-for#DECLARE CURSOR FOR":"Defines a result set that can be processed by a loop.","declarehandler#DECLARE...HANDLER":"Defines a handler that's executed when a stored program encounters an error.类比 Python 的 try...catch。","变量声明与赋值#变量声明与赋值":"变量存储一个值，该值可以在过程执行时被更改。变量声明语法格式：\nDECLARE variable_name data_type [DEFAULT literal_value];\n赋值方法：\n变量申明时赋值：\nDECLARE vendor id var INT DEFAULT 95;\n使用 SET 语句：\nSET variable_name literal_value_or_expression;\n使用 SELECT 语句：\nSELECT column 1[,column_2]...\nINTO variable_name_1[,variable_name_2]...\nmysql 存储过程中 declare 和 set 定义变量的区别mysql 存储过程中，定义变量有两种方式：\n会话变量：使用 set 或 select 直接赋值，变量名以 @ 开头。如:\nset @var=1;\n可以在一个会话的任何地方声明，作用域是整个会话。它们不会被再初始化，在一个会话内，只须初始化一次，之后在会话内都是对上一次计算的结果，就相当于在是这个会话内的全局变量。\n存储过程变量：以 DECLARE 关键字声明的变量，只能在存储过程中使用。如：\nDECLARE var1 INT DEFAULT 0;\n主要用在存储过程中，或者是给存储传参数中。在调用存储过程时，这些变量都会被初始化为 NULL。","cursor#Cursor":"部分参考自 SQL -- 游标（详细）sql 游标 Mr.Li 高的博客-CSDN 博客，有删改。游标（cursor）是系统为用户开设的一个数据缓冲区，存放 SQL 语句的执行结果。每个游标区都有一个名字，用户可以用 SQL 语句逐一从游标中获取记录做进一步的处理。游标的实现功能：\n允许对 SELECT 返回的表中的每一行进行相同或不同的操作，而不是一次对整个结果集进行同一种操作；\n从表中的当前位置检索一行或多行数据；\n游标允许应用程序对当前位置的数据进行修改、删除的能力；\n对于不同用户对结果集包含的数据所做的修改，支持不同的可见性级别；\n提供脚本、存储过程、触发器中用于访问结果集中的数据的语句。\n使用步骤：\n声明游标\n打开游标\n读取游标\n释放游标","声明游标#声明游标":"声明游标是指用 DECLARE 语句创建一个游标。声明游标主要包括以下内容：游标名称、数据来源、选取条件和属性。\nDECLARE 游标名称 CURSOR\n[ LOCAL | GLOBAL ]                                   -- 游标的作用域\n[ FORWORD_ONLY | SCROLL ]                            -- 游标的移动方向\n[ STATIC | KEYSET | DYNAMIC | FAST_FORWARD ]         -- 游标的类型\n[ READ_ONLY | SCROLL_LOCKS | OPTIMISTIC ]            -- 游标的访问类型\n[ TYPE_WARNING]                                      -- 类型转换警告语句\nFOR SELECT 语句                                      -- SELECT查询语句\n[ FOR { READ ONLY | UPDATE [OF 列名称]}][,...n]      -- 可修改的列\n如：\n-- 声明游标\nDECLARE curl CURSOR\nFOR SELECT * FROM student\n-- 将游标变量 @var_curl 与 curl相关联\nDECLARE @var_curl CURSOR\nSET @var_curl=curl\nDeclare an error handler for when no rows are found in the cursor:\nDECLARE CONTINUE HANDLER FOR NOT FOUND handler_statement;","打开游标#打开游标":"游标声明后，如果要从游标中读取数据必须要打开游标。打开游标是指打开已经声明但尚未打开的游标，并执行游标中定义的查询。\nOPEN cursor_name;\n在游标被成功打开后，全局变量 @@CORSOR_ROWS 用来记录游标内的数据行数。返回值有四种：\n返回值\t描述\t-m\t表示仍在从基础表向游标读入数据，m 表示当前在游标中的数据行数\t-1\t该游标是一个动态游标，其返回值无法确定\t0\t无符合调剂的记录或游标已经关闭\tn\t从基础表向游标读入数据已结束，n 为游标中已有的数据记录行数\t\n如：创建游标 curl，使 curl 可以对 student 表所有的数据进行操作，然后打开该游标，输出游标中的行数。\n-- 打开 curl 游标\nOPEN curl\nSELECT '游标curl数据行数' = @@CURSOR_ROWS\n-- 结果：-1","读取游标#读取游标":"当游标打开后就可以使用 FETCH 命令从游标中逐行地读取数据，以进行相关处理。\n-- 读取数据的位置\nFETCH [[ NEXT | PRIOR | FIRST | LAST | ABSOLUTE{n|@nvar }| RELATIVE { n|@nvar }] FROM ]\n{{[ GLOBAL] 游标名称} | @游标变量名称 }\n-- 将读取的游标数据存放到指定变量中\n[ INTO @游标变量名称 ][,...n]\nFETCH 语句执行时，可以使用全局变量 @@FETCH_STATUS 返回上次执行 FETCH 命令的状态。在每次用 fetch 从游标中读取数据时，都应检查该变量，以确定上次 FETCH 操作是否成功，来决定如何进行下一步处理。返回值有三种：\n返回值\t描述\t0\tFETCH 命令被成功执行\t1\tFETCH 命令失败或者行数据超过游标数据结果集的范围\t2\t所读取的数据已经不存在\t\n如：从游标中提取数据，并查看 FETCH 命令的执行状态。Close the cursor:\nCLOSE cursor_name"}},"/experiment/05-access-control":{"title":"05 Mysql access control","data":{"用户管理#用户管理":"","创建用户#创建用户":"格式：\nCREATE USER [IF NOT EXISTS]\n    user [auth_option] [, user [auth_option]] ...\n    DEFAULT ROLE role [, role ] ...\n    [REQUIRE {NONE | tls_option [[AND] tls_option] ...}]\n    [WITH resource_option [resource_option] ...]\n    [password_option | lock_option] ...\n    [COMMENT 'comment_string' | ATTRIBUTE 'json_object']\nuser:\n    (see Section 6.2.4, “Specifying Account Names”)\nauth_option: {\n    IDENTIFIED BY 'auth_string' [AND 2fa_auth_option]\n  | IDENTIFIED BY RANDOM PASSWORD [AND 2fa_auth_option]\n  | IDENTIFIED WITH auth_plugin [AND 2fa_auth_option]\n  | IDENTIFIED WITH auth_plugin BY 'auth_string' [AND 2fa_auth_option]\n  | IDENTIFIED WITH auth_plugin BY RANDOM PASSWORD [AND 2fa_auth_option]\n  | IDENTIFIED WITH auth_plugin AS 'auth_string' [AND 2fa_auth_option]\n  | IDENTIFIED WITH auth_plugin [initial_auth_option]\n}\ntls_option: {\n   SSL\n | X509\n | CIPHER 'cipher'\n | ISSUER 'issuer'\n | SUBJECT 'subject'\n}\nresource_option: {\n    MAX_QUERIES_PER_HOUR count\n  | MAX_UPDATES_PER_HOUR count\n  | MAX_CONNECTIONS_PER_HOUR count\n  | MAX_USER_CONNECTIONS count\n}\npassword_option: {\n    PASSWORD EXPIRE [DEFAULT | NEVER | INTERVAL N DAY]\n  | PASSWORD HISTORY {DEFAULT | N}\n  | PASSWORD REUSE INTERVAL {DEFAULT | N DAY}\n  | PASSWORD REQUIRE CURRENT [DEFAULT | OPTIONAL]\n  | FAILED_LOGIN_ATTEMPTS N\n  | PASSWORD_LOCK_TIME {N | UNBOUNDED}\n}\n如：：\ncreate user 'user01' @'localhost' identified by 'user01';\n注：用户的添加修改删除等操作都是在 root 权限下操作的！\n其中：\nPASSWORD：用于指定散列口令，即若使用明文设置口令，则需忽略 PASSWORD 关键字；若不想以明文设置口令，且知道 PASSWORD() 函数返回给密码的散列值，则可以在口令设置语句中指定此散列值，但需要加上关键字 PASSWORD。\n创建用户账号，格式为 'user_name'@'host_name’。user_name 是用户名，host_name 为主机名，即用户连接 MySQL 时所在主机的名字。\n若在创建的过程中，只给出了账户的用户名，而没指定主机名，则主机名默认为“%”，表示一组主机\n此外需要注意：\n如果使用 CREATE USER 语句时没有为用户指定口令，那么 MySQL 允许该用户可以不使用口令登录系统，然而从安全的角度而言，不推荐这种做法。\n使用 CREATE USER 语句必须拥有 MySQL 中 mysql 数据库的 INSERT 权限或全局 CREATE USER 权限。\n使用 CREATE USER 语句创建一个用户账号后，会在系统自身的 MySQL 数据库的 user 表中添加一条新记录。若创建的账户已经存在，则语句执行时会出现错误。\n新创建的用户拥有的权限很少。他们可以登录 MySQL，只允许进行不需要权限的操作，如使用 SHOW 语句查询所有存储引擎和字符集的列表等。\n如果两个用户具有相同的用户名和不同的主机名，MySQL 会将他们视为不同的用户，并允许为这两个用户分配不同的权限集合。","更改用户#更改用户":"更改用户信息主要包括重命名，改密码，锁定或解锁用户。下面将通过案例为大家展示这些用法：\n# 重命名用户\nRENAME USER 'test user'@'%'to 'test'@'%';\n# 修改密码\nALTER USER 'test'@'%'identified by '123456789';\n# 锁定或解锁用户\nALTER USER 'test'@'%'ACCOUNT LOCK;\nALTER USER 'test'@'%'ACCOUNT UNLOCK;","删除用户#删除用户":"方法一：使用 SQL 自带功能删除格式：\nDROP USER [IF EXISTS] user [, user] ...\n如：\nDROP USER jeffrey'@'localhost'\n方法二：使用 DELETE 语句删除\nDELETE FROM mysql.user\nWHERE user='tom' AND host='localhost';\n-- 注意还要更新授权表：\nFLUSH PRIVILEGES;","权限管理#权限管理":"对登录到 MySQL 的用户进行权限验证。\n所有用户的权限都存储在 MySQL 的权限表中，不合理的权限规划会给 MySQL 服务器带来安全隐患。\nMySQL 权限系统可验证连接到一台给定主机的用户，并且赋予该用户在各类权限。\n账户权限信息被存储在 MySQL 数据库的   user、db、host、tables_priv、column_priv 和 procs_priv 表中。\nMySQL 启动时，服务器将这些数据库表中的权限信息的内容读入内存。","创建角色#创建角色":"CREATE ROLE creates one or more roles, which are named collections of privileges.格式：\nCREATE ROLE [IF NOT EXISTS] role [, role] ...\n如：\nCREATE ROLE 'administrator','developer';\nCREATE ROLE 'webapp'@'localhost';","删除角色#删除角色":"DROP ROLE [IF EXISTS] role [, role]...","权限#权限":"","用户授权#用户授权":"授权用户：\nGRANT priv_type [(column_list)]\n[, priv_type [(column_list)]]\nON [object_type] priv_level\nTO user_or_role [, user_or_role]\n[WITH GRANT OPTION]\n[AS user\n\t[WITH ROLE\n         DEFAULT | NONE | ALL\n         | ALL EXCEPT role [, role ] ...\n         | role [, role ］...\n    ]\n]\n授权角色：\nGRANT role [role] ...\nTO user_or_role [user_or_role]...\n[WITH ADMIN OPTION]\n如授权用户：\nGRANT ALL ON db1.* TO 'jeffrey'@'localhost';\nGRANT 'role1', 'role2'\nTO 'user1'@'localhost', 'user2'@'localhost';\nGRANT SELECT ON world.* TO 'role3';\n如授权角色：\nCREATE USER 'jeffrey'@'localhost' IDENTIFIED BY 'password';\nGRANT ALL ON db1.* TO 'jeffrey'@'localhost';\nGRANT SELECT ON db2.invoice To 'jeffrey'@'localhost';\nALTER USER 'jeffrey'@'localhost' WITH MAX_QUERIES_PER_HOUR 90;","权限分级#权限分级":"全局层级\n数据库层级\n表层级\n列层级\n子程序层级","全局层级#全局层级":"Global privilegesGlobal privileges are administrative or apply to all databases on a given server. To assign global privileges,use on *.syntax:\nGRANT ALL ON *.TO someuser'@'somehost';\nGRANT SELECT,INSERT ON *.TO 'someuser'@'somehost';\n注：存储在 mysql.user 表中","数据库层级#数据库层级":"Database privilegesDatabase privileges apply to all objects in a given database.To assign database-level privileges,use on db_name.syntax:\nGRANT ALL ON mydb.* TO someuser'@'somehost';\nGRANT SELECT, INSERT ON mydb.* TO someuser'@'somehost';\n注：存储在 mysql.db 和 mysql.host 表中","列层级#列层级":"Column privilegesColumn privileges apply to single columns in a given table.Each privilege to be granted at the column level must be followed by the column or columns,enclosed within parentheses.\nGRANT SELECT (col1), INSERT (col1,col2) ON mydb.mytbl TO someuser'@'somehost';\n注：存储在 mysql.columns_priv 表中","子程序层级#子程序层级":"Stored Routine PrivilegesThe ALTER ROUTINE, CREATE ROUTINE, EXECUTE and GRANT OPTION privileges apply to stored routines (procedures and functions). They can be granted at the global and database levels. Except for CREATE ROUTINE, these privileges can be granted at the routine level for individual routines.GRANT CREA\nGRANT CREATE ROUTINE ON mydb.* TO 'someuser'@'somehost';\nGRANT EXECUTE ON PROCEDURE mydb.myproc TO someuser'@'somehost';\n注：存储在 mysql.procs_priv 表中MySQL 权限表的验证过程为：\n先从 user 表中的 Host, User, Password 这 3 个字段中判断连接的 ip、用户名、密码否存在，存在则通过验证。\n通过身份认证后，进行权限分配，按照 user，db，tables_priv，columns_priv， mysql.procs_priv 的顺序进行验证。即先检查全局权限表 user，如果 user 中对应的权限为 Y，则此用户对所有数据库的权限都为 Y，将不再检查 db, tables_priv,columns_priv；如果为 N，则到 db 表中检查此用户对应的具体数据库，并得到 db 中为 Y 的权限；如果 db 中为 N，则检查 tables_priv 中此数据库对应的具体表，取得表中的权限 Y，以此类推。","查看用户权限#查看用户权限":"查看所有用户：\nSELECT user,host FROM mysql.user;\n查看单个用户所有情况：\nSELECT * FROM mysql.user WHERE user='root'\\G\n-- \\g 相当于 ’;’\n-- \\G 使每个字段打印到单独的行，也有 ’;’ 的作用\n一共有这些：看自己的权限：\nSHOW GRANTS\\G\n看别人的权限：\nSHOW GRANTS FOR tom@'localhost'\\G","角色用户授权#角色、用户授权":"授权：\nGRANT 'role1','role2' TO 'user1'@'localhost','user2'@'localhost';\n收回权限：\nREVOKE\n\tpriv_type [(column_list)]\n\t\t[priv_type [(column_list)]] ...\n\tON [object_type]priv_level\n\tFROM user_or_role [user_or_role] ...\nREVOKE ALL [PRIVILEGES],GRANT OPTION\n\tFROM user_or_role [user_or_role] ...\n如：\nREVOKE INSERT ON *FROM 'jeffrey'@'localhost';\nREVOKE 'role1','role2' FROM 'user1'@'localhost', 'user2'@'localhost';\nREVOKE SELECT ON world.FROM 'role3';","查询权限#查询权限":"SHOW GRANTS\n\t[FOR user_or_role [USING role [role] ... ]]\nuser_or_role: {\n\tuser (see Section 6.2.4,\"Specifying Account Names\")\n\t| role (see Section 6.2.5,\"Specifying Role Names\"\n}\n如：\nSHOW GRANTS FOR jeffrey'@'localhost';"}},"/":{"title":"Database Learning – Created by CWorld","data":{"":"Database Learning \nby CWorld\n关于 CWorld 学习 Database 一些笔记和代码。"}},"/last":{"title":"At the last","data":{"":"感谢能看到最后！相信你已经完全掌握本门课程了。下面是考点与考试说明。","考试内容分布#考试内容分布":"The relational model of data. (10 marks)\nConceptual modeling. (20 marks)即概念建模。考点诸如 ER diagram、聚集等\nQueries. (45 marks)SQL, and relational algebra, and safe relational calculus.即 SQL 语句、关系代数和安全关系演算。\nDatabase design. (25 marks)考点如函数依赖、范式等。数据库分解也会考，如无损分解等。"}},"/intro":{"title":"Introduction","data":{"":"关于 CWorld 学习 Database 一些笔记和代码。点击侧栏的目录或滑到底部的下一篇文章以阅览更多章节。","development#Development":"如果你对该项目有兴趣，请前往 Github 了解更多。","contributions#Contributions":"由于作者只是个正在浅学 Database 的初学者，所以笔记难免存在明显纰漏，还请读者们多多海涵。此外，也欢迎诸位使用 PR 或 Issues 来改善它们。","thanks#Thanks":"一些电子教材对作者学习上帮助颇多，没有这些资料，就没有这部笔记。在此对这些教材的原作者深表感谢。读者若对此项目笔记抱有疑惑，也可以仔细阅读以下教材以作弥补。\n数据库原理及应用 - shark-Gao 的博客\n数据库原理及应用教程（微课版）\n数据库系统概论（第 5 版）","license#License":"This project is licensed under the GPL 3.0 License.This documention is admitted by Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0).\nNote This website is built using Nextra, a modern static website generator."}},"/opengauss":{"title":"OpenGauss","data":{}},"/opengauss/01-getting-started":{"title":"初识 OpenGauss","data":{"创建数据库#创建数据库":"数据库其实就是可以存放大量数据的仓库，学习数据库我们就从创建一个数据库开始吧。","数据库逻辑结构图#数据库逻辑结构图":"openGauss 的数据库节点负责存储数据，其存储介质也是磁盘，下面主要从逻辑视角介绍数据库节点都有哪些对象，以及这些对象之间的关系。数据库逻辑结构如下图。说明：\nTablespace，即表空间，是一个目录，可以存在多个，里面存储的是它所包含的数据库的各种物理文件。每个表空间可以对应多个 Database。\nDatabase，即数据库，用于管理各类数据对象，各数据库间相互隔离。数据库管理的对象可分布在多个 Tablespace 上。\nDatafile Segment，即数据文件，通常每张表只对应一个数据文件。如果某张表的数据大于 1GB，则会分为多个数据文件存储。\nTable，即表，每张表只能属于一个数据库，也只能对应到一个 Tablespace。每张表对应的数据文件必须在同一个 Tablespace 中。\nBlock，即数据块，是数据库管理的基本单位，默认大小为 8KB。","opengauss-数据库的特征#OpenGauss 数据库的特征":"以下是 OpenGauss 数据库特征：\n用户必须拥有数据库创建的权限或者是数据库的系统管理员权限才能创建数据库；\nopenGauss 默认包含两个模板数据库 template0、template1，以及一个默认的用户数据库 postgres。如图所示：\n用户创建数据库时实际上就是通过拷贝模板数据库（默认 template1)来创建新的数据库，同时，要避免使用客户端或其他手段连接及操作两个模板数据库；\nopenGauss 允许创建的数据库总数目上限为 128 个。数据库系统中会有多个数据库，但是客户端程序一次只能连接一个数据库。也不能在不同的数据库之间相互查询。","如何连接数据库#如何连接数据库":"gsql 是 openGauss 提供的在命令行下运行的数据库连接工具。平台连接数据库的语句如下：\ngsql -d postgres -U gaussdb -W'passwd123@123';\n其中 -d 参数代表数据库，-U 参数代表用户名，-W 参数代表密码； 连接成功后，系统会显示“DBNAME=>”。退出连接使用以下语句：\npostgres=> \\q\nopenGauss 常用操作语句：切换数据库：\n\\c test\n上述语句代表从当前数据库切换到 test 数据库。查看数据库列表：\n\\l\n查看表列表及表信息：\n\\d","如何创建数据库#如何创建数据库":"创建数据库： 创建一个新的数据库。缺省情况下新数据库将通过复制标准系统数据库 template0 来创建，且仅支持使用 template0 来创建。另外需要注意的是，在创建数据库过程中，若出现类似“could not initialize database directory”的错误提示，可能是由于文件系统上数据目录的权限不足或磁盘满等原因引起。创库语法格式：\nCREATE DATABASE database_name\n    [ [ WITH ] { [ OWNER [=] user_name ] |\n               [ TEMPLATE [=] template ] |\n               [ ENCODING [=] encoding ] |\n               [ LC_COLLATE [=] lc_collate ] |\n               [ LC_CTYPE [=] lc_ctype ] |\n               [ DBCOMPATIBILITY [=] compatibilty_type ] |\n               [ TABLESPACE [=] tablespace_name ] |\n               [ CONNECTION LIMIT [=] connlimit ]}[...] ];\n上述建表语句中，OWNER 参数可用于指定表的所属用户，TEMPLATE 参数可用于指定模板数据库，ENCODING 参数可用于编码格式，TABLESPACE 参数可用于指定表空间。创建数据库示例：\n--创建一个GBK编码的数据库music（本地环境的编码格式必须也为GBK）。\npostgres=# CREATE DATABASE music ENCODING 'GBK' template = template0;\n--创建数据库music2，并指定所有者为jim。\npostgres=# CREATE DATABASE music2 OWNER jim;\n--用模板template0创建数据库music3，并指定所有者为jim。\npostgres=# CREATE DATABASE music3 OWNER jim TEMPLATE template0;","创建表#创建表":"我们知道数据库就是存储数据的地方，那数据库中的数据到底存放在哪里呢？数据库中的数据是存放在一张一张的表中的。 你可以想象数据库就像一个文件夹，而表你可以理解为一个 excel 表格，其实他们本来就挺像。","如何在指定数据库中创建表#如何在指定数据库中创建表":"我们先来了解一下在数据库中创建表的规则：\nCREATE TABLE 表名(\n    字段名,数据类型,\n    字段名,数据类型,\n    .....\n)\n首先创建数据库，如下：\ncreate database mydb;\n然后选择数据库：\n\\c mydb;\n最后创建 tb1 表:\nCREATE TABLE tb1(\n    c_sk             integer,\n    c_id             char(5),\n    c_name              char(6),\n    c_sex               char(8)\n);\n上述建表语句中， c_sk 、c_id、c_name 和 c_sex 代表表的字段名，integer、char(5)、char(6) 和 char(8) 分别是这四字段名称的数据类型。当结果显示如下信息时，表示表创建成功：\nCREATE TABLE\n也可以输入 \\d 命令查看数据库下的表列表；\\d+ 可以查看表的具体信息。","使用主键约束#使用主键约束":"主键，是表中一列或者多列的组合，主键约束（Primary Key Constraint）要求主键列的数据唯一，并且不允许为空，主键能够唯一的标识表中的每一条记录，可以结合外键来定义与不同数据表之间的关系。 怎么理解主键呢？我们知道数据库中的表可以存放很多数据，如果把表中的每一个数据比作一个人的话，那么表的主键就可以看做是人的身份证。为了完成本关任务，你需要掌握：怎么给表中的字段添加主键约束。","添加主键约束#添加主键约束":"有两种方式可以添加主键约束：\n在定义列的同时指定主键：\nCREATE TABLE tb1(\n    id int PRIMARY KEY,\n    name varchar(32),\n    deptId int,\n    salary float\n);\n指定 id 列为主键。\n在定义完所有列之后指定主键：\nCREATE TABLE tb1(\n    id int,\n    name varchar(32),\n    deptId int,\n    salary float,\n    PRIMARY KEY(id)\n);","多字段联合主键#多字段联合主键":"在开发中还有一种情况很常见，就是将几个字段联合在一起作为主键，那这个在代码中怎么实现呢？ 举个例子，我们将员工的名字和部门 ID 联合起来作为主键：\nCREATE TABLE tb1(\n    id int,\n    name varchar(32),\n    deptId int,\n    salary float,\n    PRIMARY KEY(id,name)\n);\n语句执行后，会将 name 和 id 字段组合成为表 tb1 的多字段组合主键。","添加常用约束#添加常用约束":"在数据库的使用过程中我们经常要限制字段的取值，比如有些字我们不能让它为空，我们就需要添加非空约束，本关我们就来学习如何添加这些常用的约束。为了完成本关任务，你需要掌握：\n怎么添加唯一约束；\n怎么添加非空约束；\n怎么添加默认约束；\n怎么设置字段的值自动增加。","怎么添加唯一约束#怎么添加唯一约束":"唯一约束（Unique Constraint）要求该列唯一，允许为空，但是只能有一个空值。唯一约束可以确保一列或者几列不出现重复值。定义部门表的部门名称唯一，SQL 语句如下：关键词 UNIQUE。\nCREATE TABLE t_dept(\n    id INT PRIMARY KEY,\n    name VARCHAR(22) UNIQUE,\n    location VARCHAR(50));","怎么添加非空约束#怎么添加非空约束":"关键词：NOT NULL；例如：\nCREATE TABLE t_dept(\n    id INT PRIMARY KEY,\n    name VARCHAR(22) NOT NULL,\n    location VARCHAR(50));","怎么使用默认约束#怎么使用默认约束":"默认约束：即给字段一个默认值。 关键词：DEFAULT；例如：\nCREATE TABLE t_emp(\n    id INT PRIMARY KEY,\n    name VARCHAR(22),\n    sex VARCHAR(2) DEFAULT '男') ;\n注意：如果是添加字符串型默认值要使用单引号，如果是整型则不需要加任何符号；","设置表的属性值自动增加#设置表的属性值自动增加":"在数据库应用中，经常有个需求就是，在每次插入新纪录时，系统自动生成字段的主键值，即：关键词：serial，默认情况下初始值和增量都为 1。例如：\nCREATE TABLE T1(\n    id    serial,\n    name  text,\n    primary key(id));"}},"/opengauss/02-basic-queries":{"title":"连接查询和子查询","data":{"内连接查询#内连接查询":"为了完成本关任务，你需要掌握：1.什么是内连接查询； 2.如何使用内连接查询。","内连接查询-1#内连接查询":"仅将两个表中满足连接条件的行组合起来作为结果集，称为内连接；\n关键字：[inner] join ...  on。\n语法：\n表1 [inner] join 表2 on 表1.字段=表2.字段\n语法解释：从表 1 中取出每一条记录，去表 2 中与所有的记录进行匹配，匹配必须是某个条件在表 1 中与表 2 中相同，最终才会保留结果，否则不保留。inner 关键字可省略不写；on 表示连接条件：条件字段就是代表相同的业务含义（如下面两张表中的 employee.dept_id 和 department.id），大多数情况下为两张表中的主外键关系。","内连接查询的使用#内连接查询的使用":"现在我们有两张表，数据如下： employee表数据：\nid\tname\tdept_id\t1\tNancy\t4\t2\tTod\t2\t3\tCarly\t1\t4\tAllen\t2\t5\tMary\t(null)\t\ndepartment表数据：\nid\tname\t1\t开发部\t2\t测试部\t3\t运维部\t4\t销售部\t\n现在想要查询出员工姓名以及其对应的部门名称，我们就使用内连接来进行查询。\n我们可以将关联查询思路分为三步：\n确定所连接的表\n确定所要查询的字段，\n确定连接条件与连接方式。\n示例：\nselect emp.name as empname,dept.name as deptname\nfrom department as dept\njoin employee as amp on dept.id=emp.dept_id;\n结果：\nempname\tdeptname\tCarly\t开发部\tTod\t测试部\tAllen\t测试部\tNancy\t销售部\t\n其中，没有部门的员工和部门没有员工的部门都没有被查出来，这就是内连接的特点，只查询在连接表中有对应的记录，其中 dept.id=emp.dept_id 是连接条件。","外连接查询#外连接查询":"为了完成本关任务，你需要掌握：1.什么是外连接查询； 2.如何使用外连接查询。","外连接查询-1#外连接查询":"以某张表为主，取出里面的所有记录，然后每条与另外一张表进行连接，不管能不能匹配上条件，最终都会保留。能匹配，正确保留；不能匹配，其它表的字段都置空（null），称为外连接。\n外连接查询分为左外连接查询和右外连接查询；\n关键字：left/right [outer] join ... on。\n语法：\n表1 left/right [outer]  join 表2 on 表1.字段=表2.字段\n语法解释：左外连接：在内连接的基础上，还包含表 1 中所有不符合条件的数据行，并在其中的表 2 列填写 NULL；右外连接：在内连接的基础上，还包含表 2 中所有不符合条件的数据行，并在其中的表 1 列填写 NULL。","外连接查询的使用#外连接查询的使用":"我们仍使用如下两张数据表：employee表数据：\nid\tname\tdept_id\t1\tNancy\t4\t2\tTod\t2\t3\tCarly\t1\t4\tAllen\t2\t5\tMary\t(null)\t\ndepartment表数据：\nid\tname\t1\t开发部\t2\t测试部\t3\t运维部\t4\t销售部\t\n例如查询所有员工姓名以及他所在部门，在内连接中 Mary 没有被查出，因为他没有对应的部门，现在想把 Mary 也查出来，就要使用左外连接。此查询语句以 employee 为主表查询，因此最终记录至少不少于主表已有的记录数。\n右外连接是同理的，只是基准表的位置变化了而已。\n我们在这里只是将 left 修改成了 right ,但是基准表变化了，是以 department 表的数据去匹配 employee 表，所以左外连接能做到的查询，右外连接也能做到，仅展现的效果有所不同。虽然左外连接和右外连接有主表差异，但左外连接和右外连接可以互转，如上面的右外连接也等效于如下查询语句，只需将基准表换一下：","关键字子查询#关键字子查询":"由于列子查询返回的结果集是 N 行一列，因此不能直接使用 = 、>、<、>=、<=、<>这些比较标量结果的操作符。在列子查询中可以使用 ALL、ANY、SOME 和 IN关键字操作符。为了完成本关任务，你需要掌握：如何在子查询中使用关键字进行查询。","all-关键字#ALL 关键字":"ALL必须接在一个比较运算符的后面，表示与子查询返回的所有值比较都为 TRUE 则返回 TRUE。table1 表数据：\ncol1\t2\t10\t\ntable2 表数据：\ncol2\t5\t12\t20\t\n举个例子：\nSELECT col1 FROM table1 WHERE col1 > ALL (SELECT col2 FROM table2)\n该查询语句不会返回任何结果，因为 col1 中没有比 col2 所有值都大的值。","any-和-some-关键字#ANY 和 SOME 关键字":"ANY 与比较操作符联合使用，表示与子查询返回的任何值比较为 TRUE ，则返回 TRUE。 SOME 是 ANY 的别名，一般用的比较少。仍使用上面二张表的数据：在子查询中，返回的是 table2 的所有 col2列的结果 （5,12,20），然后将 table1 中 col1 的值与之进行比较，只要大于col2的任何值则为TRUE，因此查询结果为10。","in-关键字#IN 关键字":"IN 的意思就是指定的一个值是否在这个集合中，如果在就返回 TRUE；否则就返回 FALSE 了，同 IN (项 1，项 2，...)；\nIN 是 = ANY 的别名，二者相同，但 NOT IN 的别名却不是 <> ANY 而是 <> SOME。","分页子查询#分页子查询":"如何根据页数和每页数据量进行分页查询；\n大数据量级进行优化分页查询。","什么是分页查询#什么是分页查询":"当一个表中有很多符合查询条件的数据的时候，我们往往不需要把他们全部一次性取出来，那样对查询效率或者服务器性能来说都会是一个极大的挑战:例如最简单的商城，假设商城中有一万个数据，但我们在前端可能只会每次看到一页 10 个左右的数据，当我们浏览完这十个商品后，点击下一页浏览其他的商品，这样的分页浏览，对实际存储商品数据的 MySQL 数据库来说，实际上就是使用了 MySQL 的分页查询功能。那么我们该怎么实现分页查询呢？","limit-和-offset-实现的分页查询#limit 和 offset 实现的分页查询":"limit 在之前的学习中应该有学习到，它可以返回符合条件的 limit 条数据：\nselect * from table where xxx=\"xxx\" limit 10;\n输出： 检索记录行符合条件的10条数据那么我们也可以利用 limit 和 offset 来进行分页查询:\nselect * from table where xxx=\"xxx\" limit 10 offset 10;\n输出：检索记录行符合条件的 11-20 条数据limit 之后的数字代表偏移量，offset 代表返回记录的最大值，可以通俗的理解为，从 table 中取出第 limit+1 行到 limit+offset+1 行数据(MySQL 偏移值从 0 开始计算)。在实际使用中，我们可以直接把 offset 直接省略掉：\nselect * from table where xxx=\"xxx\" limit 10,10;\n该语句效果与带 offset 实际上是一模一样的。通过分页查询，我们可以精确的定位到行数直接取出符合条件的多条数据，但是这也同样存在着性能问题。","大数据量下分页查询优化#大数据量下分页查询优化":"select * from table where xxx=\"xxx\" limit 100,100;\nselect * from table where xxx=\"xxx\" limit 1000,100;\nselect * from table where xxx=\"xxx\" limit 10000,100;\nselect * from table where xxx=\"xxx\" limit 100000,100;\nselect * from table where xxx=\"xxx\" limit 1000000,100;\n以上语句在实际使用中实际上查询速度会是越来越慢的，这是因为分页查询方式会从数据库第一条记录开始扫描，所以越往后，查询速度越慢，而且查询的数据越多，也会拖慢总查询速度。如果可以直接定位到偏移量所在记录，那么查询速度肯定能得到一个巨大的提升，所以可以考虑添加一个嵌套子查询，先查询到偏移量位置，再进行分页：\nselect * from table where xxx=\"xxx\" and id>=(select id from table where xxx=\"xxx\"limit 100000,1)limit 100;"}},"/opengauss/03-aggregate-fun-query":{"title":"使用聚合函数查询","data":{"count-函数#COUNT() 函数":"COUNT() 函数是用来统计记录的总条数。\nselect count(*/字段名) from 数据表;\n例子说明： 假设我们现在有一张表 tb_dept；内容如下：\nid\tname\tdept_id\t1\tNancy\t301\t2\tTob\t303\t3\tCarly\t301\t\n我们需要获取整张表有多少条数据，那么我们就可以使用 COUNT(*) 来查询了。那么，现在同样是这张表，我假若想知道 301 部门一共有少人，我们可以思考该怎么查询？相信大家都想到了，我们可以使用 where 条件进行查询：","sum-函数#SUM() 函数":"SUM() 函数是对数据表的某列进行求和操作。\nselect sum(字段名) from 数据表;\n例子说明： 现在有一张 tb_Salary 表,内容如下：\nid\tname\tSalary\tMonth\t1\tNancy\t2300\t11\t2\tTob\t5800\t11\t3\tCarly\t3200\t11\t4\tNancy\t2600\t12\t5\tTob\t6300\t12\t6\tCarly\t5200\t12\t\n假设场景公司老板想知道公司总共给员工开了多少工资，则可以使用 SUM() 函数来进行统计了。若想得知 Tob 同事在 11月 和 12月 的薪水一共有多少，加上 where 条件即可。","avg-函数#AVG() 函数":"AVG() 函数是对数据表的某列进行求平均值操作。\nselect avg(字段名) from 数据表;\n例子说明： 现在有一张 tb_Salary 表,内容如下：\nid\tname\tSalary\tMonth\t1\tNancy\t2300\t11\t2\tTob\t5800\t11\t3\tCarly\t3200\t11\t4\tNancy\t2600\t12\t5\tTob\t6300\t12\t6\tCarly\t5200\t12\t\n假设场景，老板想知道公司发给员工的薪水的平均值为多少，此时就可使用 AVG() 函数来计算了。现在又想知道 Nancy 在 11-12月份 的薪水平均有多少，则可进行如下查询：","max-函数#MAX() 函数":"MAX() 函数是求某列的最大数值。\nselect max(字段名) from 数据表;\n例子说明： 现在有一张 tb_Salary 表,内容如下：\nid\tname\tSalary\tMonth\t1\tNancy\t2300\t11\t2\tTob\t5800\t11\t3\tCarly\t3200\t11\t4\tNancy\t2600\t12\t5\tTob\t6300\t12\t6\tCarly\t5200\t12\t\n假设场景，老板想知道公司在 11-12月份 中月薪最高的是多少，此时就可使用 MAX() 函数来统计了。这样就可以看到公司中月薪最高是多少了。我们也可查询 Carly 在 11-12月份 中月薪最高是多少：MIN()函数是求某列的最小数值。\nselect min(字段名) from 数据表\n例子说明： 现在有一张tb_Salary表,内容如下：\nid\tname\tSalary\tMonth\t1\tNancy\t2300\t11\t2\tTob\t5800\t11\t3\tCarly\t3200\t11\t4\tNancy\t2600\t12\t5\tTob\t6300\t12\t6\tCarly\t5200\t12\t\n假设场景，老板想知道公司11-12月份中月薪最低的是多少，此时就可使用MIN()函数来统计了。我们仍可以快速查出Tob在11-12月份中月薪最低时是多少：","min-函数#MIN() 函数":"MIN() 函数是求某列的最小数值。\nselect min(字段名) from 数据表\n例子说明： 现在有一张 tb_Salary 表,内容如下：\nid\tname\tSalary\tMonth\t1\tNancy\t2300\t11\t2\tTob\t5800\t11\t3\tCarly\t3200\t11\t4\tNancy\t2600\t12\t5\tTob\t6300\t12\t6\tCarly\t5200\t12\t\n假设场景，老板想知道公司 11-12月份 中月薪最低的是多少，此时就可使用 MIN() 函数来统计了。我们仍可以快速查出 Tob 在 11-12月份 中月薪最低时是多少："}},"/opengauss/04-select-data-group":{"title":"分组选择数据","data":{"对查询结果进行排序#对查询结果进行排序":"","对查询结果排序#对查询结果排序":"我们知道在 OpenGauss 中从数据表中读取数据都是使用 SELECT 语句。 如果我们需要对读取的语句进行排序，我们就可以使用 Order By 子句来设定你想要按照的字段进行排序并返回结果。语法：\nSELECT 字段名 FROM 表名 ORDER BY 字段名 [ASC[DESC]];\n你还可以根据自己的需求添加 WHERE、LIKE 子句来设置条件，再对结果过进行排序显示。现有 user 表数据如下：\nid\tname\tage\t1\tTom\t32\t2\tNancy\t18\t3\tAllen\t24\t4\tJason\t23\t\n我们需要查询表中信息，要求按照年龄的升序进行排序：","指定排序方向#指定排序方向":"从上面的查询语句中我们并未看到有任何表示排序方向的关键字，在默认情况下，它是按升序排列的。\nASC 升序关键字\nDESC 降序关键字","分组查询#分组查询":"但是在实际开发中一般不会用到，本章节只作为对分组查询的了解。往后继续学习，我们会介绍分组查询与其他查询一起结合使用。","分组查询的单独使用#分组查询的单独使用":"分组查询的关键字是 Group By，查询的是每个分组中 首次出现的一条记录。语法：\nSELECT 字段名 FROM 表名 GROUP BY 字段名;\n例如： 现有 user 表数据：\nid\tname\tsex\t1\tTom\t男\t2\tNancy\t女\t3\tAllen\tNull\t4\tJason\t男\t\n我们对表中数据的性别进行分组查询：可以看出，返回了 3 条记录，分别是 sex 字段值为 Null、女、男的记录，查询结果按照 sex 字段中不同的值进行了分类，只显示每个分组中的一条记录，意义不大，一般情况下，GROUP BY 都和聚合函数一起使用。","group-by-与-聚合函数#GROUP BY 与 聚合函数":"在之前的实训中我们简单的提到过 GROUP BY 关键字，本实训让我们进一步了解 GROUP BY 与聚合函数的使用。为了完成本关任务，你需要掌握：\nGROUP BY与聚合函数的结合使用；\nGROUP BY中SELECT指定的字段限制。","group-by-与聚合函数的使用#GROUP BY 与聚合函数的使用":"基本格式：\nselect [聚合函数] 字段名 from 表名\n[where 查询条件]\n[group by 字段名]\n先提供表 Info 结构如下：\ncategory\tcount\tdigest\ta\t5\ta2002\ta\t2\ta2001\ta\t11\ta2001\tb\t10\tb2003\tb\t6\tb2002\tb\t3\tb2001\tc\t9\tc2005\tc\t9\tc2004\tc\t8\tc2003\tc\t7\tc2002\tc\t4\tc2001\t\n示例：将表中数据分类并汇总","group-by-中-select-指定的字段限制#GROUP BY 中 SELECT 指定的字段限制":"示例：\nselect category,sum(count),disgest from info\ngroup by category;\n执行后会提示下错误。这就是需要注意的一点，在 select 指定的字段要么就要包含在 Group By 语句的后面，作为分组的依据；要么就要被包含在聚合函数中。","使用-having-与-order-by#使用 HAVING 与 ORDER BY":"","使用having子句进行分组筛选#使用having子句进行分组筛选":"简单来说，having 子句用来对分组后的数据进行筛选，即 having 针对查询结果中的列发挥筛选数据作用。因此 having 通常与 Group by 连用。基本格式：\nselect [聚合函数] 字段名 from 表名 [where 查询条件]　[group by 字段名] [having 字段名 筛选条件]\n表 Info 的数据信息仍如下：\ncategory\tcount\tdigest\ta\t5\ta2002\ta\t2\ta2001\ta\t11\ta2001\tb\t20\tb2003\tb\t15\tb2002\tb\t3\tb2001\tc\t9\tc2005\tc\t9\tc2004\tc\t8\tc2003\tc\t7\tc2002\tc\t4\tc2001\t\n示例：查询将表中数据分类后数量大于20的类别信息select 语句中，where、group by、having 子句和聚合函数的执行次序如下：1.where 子句从数据源中去除不符合条件的数据；2.然后 group by 子句搜集数据行到各个组中；3.接着统计函数为各个组计算统计值；4.最后 having 子句去掉不符合其组搜索条件的各组数据行。","having-与-where-的区别#Having 与 Where 的区别":"where 子句都可以用 having 代替，区别在于 where 过滤行，having 过滤分组；\nwhere 子句的作用是在对查询结果进行分组前，将不符合 where 条件的行去掉，即在分组之前过滤数据，where 条件中不能包含聚组函数，使用 where 条件过滤出特定的行；\nhaving 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用 having 条件过滤出特定的组，也可以使用多个分组标准进行分组。\nhaving 结合 where 示例：","group-by-和-order-by#Group By 和 Order By":"基本格式\nselect [聚合函数] 字段名 from 表名 [where 查询条件]　[group by 字段名] [order by 字段名 排序方向]\n示例：（以降序方式输出数据分类的汇总）若分组字段和排序字段一样时，可不需要 order by 关键字，则只需告知排序方向，即可简写成："}},"/opengauss/05-alter-database":{"title":"修改数据库","data":{"查看表结构与修改表名#查看表结构与修改表名":"","查看数据表基本结构#查看数据表基本结构":"有强迫症或健忘症的小伙伴们在建好数据库和表以后，通常会怀疑自己刚才是不是敲错了，怎么办？如果不是使用图形界面是不是就没法查看啦？不存在的，这就告诉你查看口令；\\d+ 语法规则为：\n\\d+ 表名;\n比如本岛主新建了一个名叫 t_emp22 的表，结构如下：\nCREATE TABLE t_emp22(\n    id INT PRIMARY KEY,\n    id1 INT DEFAULT 2,\n    name VARCHAR(22),\n    sex VARCHAR(2) DEFAULT '男');\n现在来看看“现场”，用 \\d+ 查表的结构是这样的。\n\\d+ t_emp22;\n# \t\t\tTable \"gaussdb.t_emp22\"\n# | Column | Type                  | Modifiers                       | Storage  | Stats target | Description |\n# | ------ | --------------------- | ------------------------------- | -------- | ------------ | ----------- |\n# | id     | integer               | not null                        | plain    |              |             |\n# | id1    | integer               | default 2                       | plain    |              |             |\n# | name   | character varying(22) |                                 | extended |              |             |\n# | sex    | character varying(2)  | default '男'::character varying | extended |              |             |\n#\n# Indexes: \"t_emp22_pkey\" PRIMARY KEY, btree (id) TABLESPACE pg_defaultHas\n# OIDs: no\n# Options: orientation=row, compression=no\n\\d+ 可以查看表的字段信息，包括：字段名、字段数据类型、是否为主键、是否有默认值等。","修改表名#修改表名":"随着表越来越多，有时候你会后悔之前的数据表的名字根本没有认真斟酌过，想要重新命名一下，可以做到吗？答案是：可以！OpenGauss 是通过 ALTER TABLE 语句来修改表名的。语法规则为：\nALTER TABLE 旧表名 RENAME to 新表名;\n举个例子，我们先用 \\d 看看我们的数据库中有什么表吧。 接下来，我们使用 ALTER TABLE 将 t_emp 改名 为 testtb。\nALTER TABLE t_emp RENAME TO testtb;\n改名成功！t_emp 成功变成了 testtb。","修改字段数据类型#修改字段数据类型":"有时，在我们建好一张表后会突然发现，哎呀！数据貌似写错了！怎么办？要删了表再重新建一个新表吗？还是要删了这个字段再新建一个新的字段？都不用，OpenGauss 中修改字段类型也有专门的语句。语法规则为：\nALTER TABLE 表名 ALTER column_name TYPE data_type;\n举个例子： 现在我们要把表 t_emp22 中的字段 name 的数据类型改名为 varchar(25)。 表 t_emp22 结构如下：\nCREATE TABLE t_emp22(\n    id INT PRIMARY KEY,\n    name VARCHAR(22),\n    sex VARCHAR(2) DEFAULT '男'\n);\n输入命令：\nALTER TABLE t_emp22 ALTER name TYPE varchar(25);\n列存表只支持：\n添加字段 ADD COLUMN\n修改字段的数据类型 ALTER TYPE\n设置单个字段的收集目标 SET STATISTICS\n更改表名称\n更改表空间\n删除字段 DROP COLUMN","添加与删除字段#添加与删除字段":"","添加字段#添加字段":"因为甲方的业务需求是不停变化的，所以在数据库操作中，添加字段可是常有的事。一个完整的字段包括：字段名、数据类型和完整性约束。\n增加单列语法规则为：\nalter table table_name ADD [ COLUMN ] column_name\ndata_type [ compress_mode ] [ COLLATE collation ] [ column_constraint [ … ] ]\n增加多列语法规则为：\nalter table table_name ADD ( { column_name data_type [ compress_mode ] } [, …] )\n其中列约束 column_constraint 为：\n[CONSTRAINT constraint_name]\n{ NOT NULL | NULL | CHECK(expression) | DEFAULT default_expr |\n    UNIQUE index_parameters | PRIMARY KEY index_parameters }\n[ DEFERRABLE | NOT DEFERRABLE | INITIALLY DEFERRED |\n    INITIALLY IMMEDIATE ]\n常用约束含义：\nNOT NULL 约束：确保某列不能有 NULL 值。\nDEFAULT 约束：当某列没有指定值时，为该列提供默认值。\nUNIQUE 约束：确保某列中的所有值是不同的。\nPRIMARY Key 约束：唯一标识数据库表中的各行/记录。\n其中列的压缩可选项 compress_mode 为：\n[ DELTA | PREFIX | DICTIONARY | NUMSTR | NOCOMPRESS ]\n举个例子： 现在我们要在表 t_emp22 中增加字段 addr varchar(100)。 表 t_emp22 结构如下：\nCREATE TABLE t_emp22(    id INT PRIMARY KEY,    name VARCHAR(22),    sex VARCHAR(2) DEFAULT '男') ;\n输入命令：\nALTER TABLE t_emp22 ADD  COLUMN  addr varchar(25);","删除字段#删除字段":"有添加的需求就会有删除的需求。删除一个字段就是将数据表中的某个字段从表中移除。语法规则为：\nALTER TABLE table_name DROP [ COLUMN ] [ IF EXISTS ] column_name\n[ RESTRICT | CASCADE ]\n从表中删除一个字段，和这个字段相关的索引和表约束也会被自动删除。如果任何表之外的对象依赖于这个字段，必须声明 CASCADE ，比如视图。 DROP COLUMN 命令并不是物理上把字段删除，而只是简单地把它标记为对 SQL 操作不可见。随后对该表的插入和更新将在该字段存储一个 NULL。因此，删除一个字段是很快的，但是它不会立即释放表在磁盘上的空间，因为被删除了的字段占据的空间还没有回收。这些空间将在执行 VACUUM 时而得到回收。举个例子： 现在我们要把字段 name 从上表 t_emp22 中删除。\nALTER TABLE t_emp22  DROP COLUMN IF EXISTS name","插入数据#插入数据":"向表中插入数据最简单的方法就是使用 INSERT 语句。 INSERT 语句需要你声明要插入内容的表(table)名和内容(values)。语法规则为：\nINSERT INTO 表名 (字段名) VALUES (内容);\n使用以下 insert into 语句即可向表 tb1 中插入一条数据;\nINSERT INTO tb1(c_sk, c_id, c_name，c_sex) VALUES (3769, 'a', 'Grace'，'women'); INSERT INTO tb1(c_sk, c_id, c_name，c_sex) VALUES (3769, 'a', 'Grace'，'women');\n以上语句中，数据值是按照这些字段在表中出现的顺序列出的，并且用逗号分隔。如果我们已经知道表中字段的顺序，也可无需列出表中的字段。例如以下命令与上面的命令效果一样。\nINSERT INTO tb1 VALUES (3769, 'a', 'Grace'，'women');\n如果用户不知道所有字段的数值，可以忽略其中的一些。没有数值的字段将被填充为字段的缺省值。例如：\nINSERT INTO tb1 (c_sk, c_name) VALUES (3769, 'Grace');\n用户也可以对独立的字段或者整个行明确缺省值：\nINSERT INTO tb1(c_sk, c_id, c_name，c_sex) VALUES (3769, 'a', 'Grace'，DEFAULT);\nINSERT INTO tb1 DEFAULT VALUES;\n在表中插入多行，可以使用以下命令：\nINSERT INTO tb1(c_sk, c_id, c_name，c_sex) VALUES (3769, 'a', 'Grace'，'women'),(3777, 'b', 'bob'，'women');\nINSERT INTO tb1(c_sk, c_id, c_name，c_sex) VALUES (3769, 'a', 'Grace'，'women'),(3777, 'b', 'bob'，'women');","更新数据#更新数据":"修改已经存储在数据库中数据的行为叫做更新。用户可以更新单独一行，所有行或者指定的部分行。还可以独立更新每个字段，而其他字段则不受影响。使用 UPDATE 命令更新现有行，需要提供以下三种信息：\n表的名称和要更新的字段名；\n字段的新值；\n要更新哪些行。\n语法规则为：\nUPDATE 表名 SET 字段名1 = 内容1, 字段名2 = 内容2, 字段名3 = 内容3 WHERE 过滤条件;\n更新数据示例：\nUPDATE mytb SET c__sk = 9876 WHERE c_sk = 9527;\n上述语句中，我们更新的是 mytb 表中的 c__sk 字段，把该字段中等于“9527”的行更新成“9876”。新的字段值不仅可以是常量，也可以是变量表达式。 比如我们可以把 c_sk 列的所有数值增加 8，sql 语句如下：\nUPDATE mytb SET c__sk = c_sk+8;\n另外，我们还可以在 UPDATE 语句中同时更新多个字段。\nUPDATE mytb SET c__sk = 9876, c_name='july' WHERE c_sk = 9527;","删除数据#删除数据":"","删除表中的指定行#删除表中的指定行":"从数据表中删除数据内容需要使用 DELETE 语句，它需要 WHERE 语句来配合它来指定我们究竟应该删除哪些数据内容。语法规则为：\nDELETE FROM 表名 WHERE 条件语句;\n我们可以指定删除某一行的数据内容，当然，我们还可以指定删除很多行的数据内容，区别就在于条件语句。那么在接下来的例子里，我们来看看很多行内容是怎么删除的。删除 mytb 表中所有 c_sk 为 9527 的行示例：\nDELETE FROM mytb WHERE c_sk = 9527;","删除表中的所有行#删除表中的所有行":"删除表中的所有行就更简单了。如果需要删除表中所有的行，只需要省略 WHERE 语句即可。语法规则为：\nDELETE/TRUNCATE FROM 表名;\n小提示：建议使用 truncate，与 DELETE 不同的是，TRUNCATE TABLE 语句直接删除的是表，而不是表中的内容，删除结束后还会重新创建一个表。所以它的执行速度会比 DELETE 语句快。。删除 mytb 表所有数据命令：\ntruncate TABLE mytb;"}},"/opengauss/06-other-func-use":{"title":"其他函数的使用","data":{"字符函数#字符函数":"下面为字符串的常用函数：\n函数\t作用\tCONCAT()\t字符串的拼接\tCONCAT_WS()\t使用指定的字符将目标字符串进行拼接\tFORMAT()\t数字格式化\tLOWER()\t字符串全部转换为小写\tUPPER()\t字符串全部转换为大写\tLEFT()\t获取左侧的字符串\tRIGHT()\t获取右侧的字符串\tLENGTH()\t计算字符串的长度\tLTRIM()\t删除前导的空格\tRTRIM()\t删除后续的空格\tTRIM()\t删除前导和后续的空格\tSUBSTRING()\t字符串截取\tSUBSTRING_INDEX()\t分隔字符串\tREPLACE()\t字符串替换\t[NOT] LIKE\t模式匹配","concat-与-concat_ws#CONCAT() 与 CONCAT_WS()":"他们的作用都是将字符进行连接，但是他们之间也有一点小区别。下面是使用 CONCAT() 将 My 和 SQL 字符进行连接：CONCAT_WS() 代表使用指定字符进行连接，最少需要三个参数，第一个参数为指定连接符：","left-与-right#LEFT() 与 RIGHT()":"他们是进行左右侧的字符获取，需要两个参数，第一个参数告诉他从哪个字符串中获取，第二个参数是获取的长度：","ltrimrtrim-与-trim#LTRIM()、RTRIM() 与 TRIM()":"这三个函数都是可以去掉字符串中含有的空格，我们先使用 LENGTH() 函数来统计含有空格的字符串的长度，分别去掉其中字符前导、后导和全部的空格，下面我们来看一下他们的区别：另外 TRIM() 函数出除了能删除空格以外，还能删除字符串中自定字符：上面操作就是将 ??MySQL??? 中的前导 ? 删除，若要删除后导的 ?，只需将LEADING 替换成 TRAILING，若要将其中的 ? 都删掉，替换成 BOTH 关键字即可。","substringsubstring_index-与-replace#SUBSTRING()、SUBSTRING_INDEX() 与 REPLACE()":"","replace-函数#REPLACE() 函数":"思考：那如果在 MySQL 中间也出现了 ? 号，还能使用上面的函数进行删除吗？答疑：很显然使用之前学到过的函数是不能将中间部分的 ? 删除，那么我们如何将中间的 ? 去掉呢？就是使用 REPLACE() 函数进行字符串的替换。\n表示将字符串中的 ? 全部替换成 ''，但使用时并不表示只能一个字符替换一个字符，可以一对多形式或多对一形式：","substring-函数#SUBSTRING() 函数":"SUBSTRING() 函数是用于字符串的截取：表示从第一位（注意第一位为 1 而非 0）开始截取 MySQL 的二位字符。","substring_index-函数#SUBSTRING_INDEX() 函数":"SUBSTRING_INDEX() 函数是用于通过特殊符号将字符串分隔的：表示将字符串 www.educoder.net 通过 . 进行分隔，可从前后取字符串。","数学函数#数学函数":"","数值运算符#数值运算符":"我们常说的“加减乘除”就是数值运算符，例如：下面是常与数值结合使用的函数：\n函数\t说明\tCEIL()\t进一（向上）取整\tFLOOR()\t舍一（向下）取整\tPOWER()\t幂运算\tSQRT()\t平方根运算\tROUND()\t四舍五入\tABS()\t绝对值计算\tRAND()\t生产0-1的随机数\tTRUNCATE()\t数字截取\tDIV\t整数除法\tMOD\t取余数(取模)","ceil和-floor#CEIL()和 FLOOR()":"这两个函数都是对值进行取整，CEIL() 函数是向上取整，FLOOR() 是向下取整：","div-和-mod#DIV 和 MOD":"我们可以直接对数值使用 /（除法）或 %（取余），但仅此是计算远远不及我们的需求。因此还提供了 DIV 整数除法函数：但 MOD 取模函数与 % 计算是 等价 的：","roundpowersqrt和-truncate#ROUND()、POWER()、SQRT()和 TRUNCATE()":"ROUND() 函数：四舍五入， 下面示例为：\nPOWER() 函数：幂运算， 下面示例为 2^3=8：\nSQRT() 函数：平方根运算， 下面示例为：","比较运算符#比较运算符":"除了数值运算符，MySQL 中还有比较运算符：\n函数\t说明\t[NOT] BETWEEN...AND...\t[不]在范围内\t[NOT] IN()\t[不]在列出值范围内\tIS [NOT] NULL\t[不]为空\t\nBETWEEN...AND...：指定一个范围，只要选择的数字在这个范围内则为 1 否则为 0；\nIN()：指定列出值，只要选择的数字存在其中则为 1 否则为 0；\nIS NULL：判断字段是否为空。","日期时间函数和流程控制类函数#日期时间函数和流程控制类函数":"","时间日期操作符#时间日期操作符":"用户在使用时间和日期操作符时，对应的操作数请使用明确的类型前缀修饰，以确保数据库在解析操作数的时候能够与用户预期一致，不会产生用户非预期的结果。 比如下面示例没有明确数据类型就会出现异常错误。\nSELECT date '2001-10-01' - '7' AS RESULT;\nOpenGauss 的操作符共有四种，分别是： +、-、*、/。“+”使用示例：\nSELECT date '2001-09-28' + integer '7' AS RESULT;\n# result\n# 2001-10-05 00:00:00\n# (1 row)\nSELECT date '2001-09-28' + interval '1 hour' AS RESULT;\n# result\n# 2001-09-28 01:00:00\n# (1 row)\n“-”使用示例：\nSELECT date '2001-10-01' - date '2001-09-28' AS RESULT;\n# result\n# 3 days\n# (1 row)\n“*”使用示例：\nSELECT 900 * interval '1 second' AS RESULT;\n# result\n# 00:15:00\n# (1 row)\n“/”使用示例：\nSELECT interval '1 hour' / double precision '1.5' AS RESULT;\n# result\n# 00:40:00\n# (1 row)","日期函数#日期函数":"","age-函数#age 函数":"第一种：\nage(timestamp, timestamp)\n描述：将两个参数相减，并以年、月、日作为返回值。若相减值为负，则函数返回亦为负。返回值类型：interval示例：\nSELECT age(timestamp '2001-04-10', timestamp '1957-06-13');\n#            age\n# -------------------------\n#  43 years 9 mons 27 days\n# (1 row)\n第二种：\nage(timestamp)\n描述：当前时间和参数相减。返回值类型：interval示例：\nSELECT age(timestamp '1957-06-13');\n#            age\n# -------------------------\n#  60 years 2 mons 18 days\n# (1 row)","clock_timestamp#clock_timestamp()":"描述：实时时钟的当前时间戳。返回值类型：timestamp with time zone示例：\nSELECT clock_timestamp();\n#         clock_timestamp\n# -------------------------------\n#  2017-09-01 16:57:36.636205+08\n# (1 row)","current_datecurrent_timestampcurrent_time#current_date/current_timestamp/current_time":"","current_date#current_date":"描述：当前日期。返回值类型：date示例：\nSELECT current_date;\n#     date\n# ------------\n#  2017-09-01\n# (1 row)","current_time#current_time":"描述：当前时间。返回值类型：time with time zone示例：\nSELECT current_time;\n#        timetz\n# --------------------\n#  16:58:07.086215+08\n# (1 row)\n-- current_timestamp描述：当前日期及时间。返回值类型：timestamp with time zone示例：\nSELECT current_timestamp;\n#        pg_systimestamp\n# ------------------------------\n#  2017-09-01 16:58:19.22173+08\n# (1 row)","流程控制类函数#流程控制类函数":"函数\t说明\tIF()\t判断，流程控制\tIFNULL()\t字段值是否为空\tCASE\t搜索语句\t\nIF()函数：IF(a,b,c) 如果a为真返回b，否则返回c；\nIFNULL()函数：IFNULL(a,b) 如果a不为null返回a，否则返回b；\nCASE：CASE WHEN a then b end 判断如果a为真返回b。"}}}